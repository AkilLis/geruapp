["9962032d63735536f479442a47618fa4c633299f","aee5ab31b7044db827826eacb746978fce24cb4a",["react/lib/ReactCurrentOwner","ReactInstanceMap","ReactInstrumentation","ReactUpdates","fbjs/lib/warning"],[49,112,168,220,277],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/stack/reconciler/ReactUpdateQueue.js"],"names":["ReactCurrentOwner","require","ReactInstanceMap","ReactInstrumentation","ReactUpdates","__DEV__","warning","warnOnInvalidCallback","callback","callerName","enqueueUpdate","internalInstance","getInternalInstanceReadyForUpdate","publicInstance","get","ctor","constructor","displayName","name","current","ReactUpdateQueue","isMounted","owner","_warnedAboutRefsInRender","getName","_renderedComponent","enqueueCallbackInternal","_pendingCallbacks","push","enqueueForceUpdate","undefined","_pendingForceUpdate","enqueueReplaceState","completeState","_pendingStateQueue","_pendingReplaceState","enqueueSetState","partialState","debugTool","onSetState","queue","enqueueElementInternal","nextElement","nextContext","_pendingElement","_context","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactInstanceMap = require('ReactInstanceMap');\nvar ReactInstrumentation = require('ReactInstrumentation');\nvar ReactUpdates = require('ReactUpdates');\n\nif (__DEV__) {\n  var warning = require('fbjs/lib/warning');\n  var warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    warning(\n      callback === null || typeof callback === 'function',\n      '%s(...): Expected the last optional `callback` argument to be a ' +\n        'function. Instead received: %s.',\n      callerName,\n      '' + callback,\n    );\n  };\n}\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (__DEV__) {\n      var ctor = publicInstance.constructor;\n      warning(\n        false,\n        'Can only update a mounted or mounting component. This usually means ' +\n          'you called setState, replaceState, or forceUpdate on an unmounted ' +\n          'component. This is a no-op.\\n\\nPlease check the code for the ' +\n          '%s component.',\n        (ctor && (ctor.displayName || ctor.name)) || 'ReactClass',\n      );\n    }\n    return null;\n  }\n\n  if (__DEV__) {\n    warning(\n      ReactCurrentOwner.current == null,\n      'Cannot update during an existing state transition (such as within ' +\n        \"`render` or another component's constructor). Render methods should \" +\n        'be a pure function of props and state; constructor side-effects are ' +\n        'an anti-pattern, but can be moved to `componentWillMount`.',\n    );\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function(publicInstance) {\n    if (__DEV__) {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        warning(\n          owner._warnedAboutRefsInRender,\n          '%s is accessing isMounted inside its render() function. ' +\n            'render() should be a pure function of props and state. It should ' +\n            'never access something that requires stale data from the previous ' +\n            'render, such as refs. Move this logic to componentDidMount and ' +\n            'componentDidUpdate instead.',\n          owner.getName() || 'A component',\n        );\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  enqueueCallbackInternal: function(internalInstance, callback) {\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance, callback, callerName) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    if (!internalInstance) {\n      return;\n    }\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, callerName);\n      }\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after state is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function(\n    publicInstance,\n    completeState,\n    callback,\n    callerName,\n  ) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, callerName);\n      }\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    if (__DEV__) {\n      ReactInstrumentation.debugTool.onSetState();\n      warning(\n        partialState != null,\n        'setState(...): You passed an undefined or null state object; ' +\n          'instead, use forceUpdate().',\n      );\n    }\n\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, callerName);\n      }\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueElementInternal: function(internalInstance, nextElement, nextContext) {\n    internalInstance._pendingElement = nextElement;\n    // TODO: introduce _pendingContext instead of setting it directly.\n    internalInstance._context = nextContext;\n    enqueueUpdate(internalInstance);\n  },\n};\n\nmodule.exports = ReactUpdateQueue;\n"]}]