["a632cdb81731a790ced432743bc68df2cc361d95","d31df4a2666e42dce90ba2e6ff90a38cc9380539",["react/lib/ReactComponentTreeHook","ReactDebugTool"],[271,605,944,1291,1785,1960],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Performance/Systrace.js"],"names":["TRACE_TAG_REACT_APPS","TRACE_TAG_JSC_CALLS","_enabled","_asyncCookie","ReactSystraceDevtool","__DEV__","onBeforeMountComponent","debugID","displayName","require","getDisplayName","Systrace","beginEvent","onMountComponent","endEvent","onBeforeUpdateComponent","onUpdateComponent","onBeforeUnmountComponent","onUnmountComponent","onBeginLifeCycleTimer","timerType","onEndLifeCycleTimer","setEnabled","enabled","global","nativeTraceBeginLegacy","addHook","nativeTraceEndLegacy","removeHook","profileName","args","nativeTraceBeginSection","nativeTraceEndSection","beginAsyncEvent","cookie","nativeTraceBeginAsyncSection","endAsyncEvent","nativeTraceEndAsyncSection","counterEvent","value","nativeTraceCounter","attachToRelayProfiler","relayProfiler","attachProfileHandler","name","attachAggregateHandler","callback","swizzleJSON","measureMethods","JSON","object","objectName","methodNames","forEach","methodName","measure","objName","fnName","func","apply","arguments","ret","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Systrace\n * @flow\n */\n'use strict';\n\ntype RelayProfiler = {\n  attachProfileHandler(\n    name: string,\n    handler: (name: string, state?: any) => () => void\n  ): void,\n\n  attachAggregateHandler(\n    name: string,\n    handler: (name: string, callback: () => void) => void\n  ): void,\n};\n\n/* eslint no-bitwise: 0 */\nconst TRACE_TAG_REACT_APPS = 1 << 17;\nconst TRACE_TAG_JSC_CALLS = 1 << 27;\n\nlet _enabled = false;\nlet _asyncCookie = 0;\n\nconst ReactSystraceDevtool = __DEV__ ? {\n  onBeforeMountComponent(debugID) {\n    const displayName = require('react/lib/ReactComponentTreeHook').getDisplayName(debugID);\n    Systrace.beginEvent(`ReactReconciler.mountComponent(${displayName})`);\n  },\n  onMountComponent(debugID) {\n    Systrace.endEvent();\n  },\n  onBeforeUpdateComponent(debugID) {\n    const displayName = require('react/lib/ReactComponentTreeHook').getDisplayName(debugID);\n    Systrace.beginEvent(`ReactReconciler.updateComponent(${displayName})`);\n  },\n  onUpdateComponent(debugID) {\n    Systrace.endEvent();\n  },\n  onBeforeUnmountComponent(debugID) {\n    const displayName = require('react/lib/ReactComponentTreeHook').getDisplayName(debugID);\n    Systrace.beginEvent(`ReactReconciler.unmountComponent(${displayName})`);\n  },\n  onUnmountComponent(debugID) {\n    Systrace.endEvent();\n  },\n  onBeginLifeCycleTimer(debugID, timerType) {\n    const displayName = require('react/lib/ReactComponentTreeHook').getDisplayName(debugID);\n    Systrace.beginEvent(`${displayName}.${timerType}()`);\n  },\n  onEndLifeCycleTimer(debugID, timerType) {\n    Systrace.endEvent();\n  },\n} : null;\n\nconst Systrace = {\n  setEnabled(enabled: boolean) {\n    if (_enabled !== enabled) {\n      if (__DEV__) {\n        if (enabled) {\n          global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JSC_CALLS);\n          require('ReactDebugTool').addHook(ReactSystraceDevtool);\n        } else {\n          global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JSC_CALLS);\n          require('ReactDebugTool').removeHook(ReactSystraceDevtool);\n        }\n      }\n      _enabled = enabled;\n    }\n  },\n\n  /**\n   * beginEvent/endEvent for starting and then ending a profile within the same call stack frame\n  **/\n  beginEvent(profileName?: any, args?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);\n    }\n  },\n\n  endEvent() {\n    if (_enabled) {\n      global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);\n    }\n  },\n\n  /**\n   * beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either\n   * occur on another thread or out of the current stack frame, eg await\n   * the returned cookie variable should be used as input into the endAsyncEvent call to end the profile\n  **/\n  beginAsyncEvent(profileName?: any): any {\n    const cookie = _asyncCookie;\n    if (_enabled) {\n      _asyncCookie++;\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie, 0);\n    }\n    return cookie;\n  },\n\n  endAsyncEvent(profileName?: any, cookie?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie, 0);\n    }\n  },\n\n  /**\n   * counterEvent registers the value to the profileName on the systrace timeline\n  **/\n  counterEvent(profileName?: any, value?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceCounter &&\n        global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);\n    }\n  },\n\n  /**\n   * Relay profiles use await calls, so likely occur out of current stack frame\n   * therefore async variant of profiling is used\n  **/\n  attachToRelayProfiler(relayProfiler: RelayProfiler) {\n    relayProfiler.attachProfileHandler('*', (name) => {\n      const cookie = Systrace.beginAsyncEvent(name);\n      return () => {\n        Systrace.endAsyncEvent(name, cookie);\n      };\n    });\n\n    relayProfiler.attachAggregateHandler('*', (name, callback) => {\n      Systrace.beginEvent(name);\n      callback();\n      Systrace.endEvent();\n    });\n  },\n\n  /* This is not called by default due to perf overhead but it's useful\n     if you want to find traces which spend too much time in JSON. */\n  swizzleJSON() {\n    Systrace.measureMethods(JSON, 'JSON', [\n      'parse',\n      'stringify'\n    ]);\n  },\n\n /**\n  * Measures multiple methods of a class. For example, you can do:\n  * Systrace.measureMethods(JSON, 'JSON', ['parse', 'stringify']);\n  *\n  * @param object\n  * @param objectName\n  * @param methodNames Map from method names to method display names.\n  */\n measureMethods(object: any, objectName: string, methodNames: Array<string>): void {\n   if (!__DEV__) {\n     return;\n   }\n\n   methodNames.forEach(methodName => {\n     object[methodName] = Systrace.measure(\n       objectName,\n       methodName,\n       object[methodName]\n     );\n   });\n },\n\n /**\n  * Returns an profiled version of the input function. For example, you can:\n  * JSON.parse = Systrace.measure('JSON', 'parse', JSON.parse);\n  *\n  * @param objName\n  * @param fnName\n  * @param {function} func\n  * @return {function} replacement function\n  */\n measure(objName: string, fnName: string, func: any): any {\n   if (!__DEV__) {\n     return func;\n   }\n\n   const profileName = `${objName}.${fnName}`;\n   return function() {\n     if (!_enabled) {\n       return func.apply(this, arguments);\n     }\n\n     Systrace.beginEvent(profileName);\n     const ret = func.apply(this, arguments);\n     Systrace.endEvent();\n     return ret;\n   };\n },\n};\n\nif (__DEV__) {\n  // This is needed, because require callis in polyfills are not processed as\n  // other files. Therefore, calls to `require('moduleId')` are not replaced\n  // with numeric IDs\n  // TODO(davidaurelio) Scan polyfills for dependencies, too (t9759686)\n  (require: any).Systrace = Systrace;\n}\n\nmodule.exports = Systrace;\n"]}]