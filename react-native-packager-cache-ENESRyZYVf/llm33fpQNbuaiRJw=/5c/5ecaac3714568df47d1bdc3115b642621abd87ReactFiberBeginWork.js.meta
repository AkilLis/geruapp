["e7ab90d19ae68192fe66f443b23252d12b343f15","c3d9c48ad89ef4e9cb0ac12283c4b76a0aa044e5",["ReactChildFiber","ReactFiberUpdateQueue","ReactTypeOfWork","ReactFiberContext","ReactPriorityLevel","ReactTypeOfSideEffect","react/lib/ReactCurrentOwner","ReactFiberClassComponent","fbjs/lib/invariant","ReactDebugCurrentFiber","ReactDebugFiberPerf","fbjs/lib/warning"],[40,329,437,482,1469,1601,1790,1861,1914,1992,2046,2146],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberBeginWork.js"],"names":["require","mountChildFibersInPlace","reconcileChildFibers","reconcileChildFibersInPlace","cloneChildFibers","beginUpdateQueue","ReactTypeOfWork","getMaskedContext","getUnmaskedContext","hasContextChanged","pushContextProvider","pushTopLevelContextObject","invalidateContextProvider","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","CoroutineComponent","CoroutineHandlerPhase","YieldComponent","Fragment","NoWork","OffscreenPriority","Placement","ContentReset","Err","Ref","ReactCurrentOwner","ReactFiberClassComponent","invariant","__DEV__","ReactDebugCurrentFiber","cancelWorkTimer","warning","warnedAboutStatelessRefs","module","exports","config","hostContext","scheduleUpdate","getPriorityContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","memoizeProps","memoizeState","adoptClassInstance","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","markChildAsProgressed","current","workInProgress","priorityLevel","progressedChild","child","progressedPriority","clearDeletions","progressedFirstDeletion","progressedLastDeletion","transferDeletions","firstEffect","lastEffect","reconcileChildren","nextChildren","pendingWorkPriority","reconcileChildrenAtPriority","memoizedProps","updateFragment","pendingProps","bailoutOnAlreadyFinishedWork","markRef","ref","effectTag","updateFunctionalComponent","fn","type","nextProps","shouldComponentUpdate","unmaskedContext","context","phase","updateClassComponent","hasContext","shouldUpdate","stateNode","finishClassComponent","instance","render","state","props","updateHostRoot","root","pendingContext","containerInfo","updateQueue","prevState","memoizedState","element","updateHostComponent","prevProps","sibling","children","isDirectTextChild","updateHostText","mountIndeterminateComponent","value","tag","Component","childContextTypes","displayName","name","info","ownerName","getCurrentFiberOwnerName","warningKey","_debugID","debugSource","_debugSource","fileName","lineNumber","getCurrentFiberStackAddendum","updateCoroutineComponent","nextCoroutine","updatePortalComponent","bailoutOnLowPriority","nextState","beginWork","beginFailedWork"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberBeginWork\n * @flow\n */\n\n'use strict';\n\nimport type {ReactCoroutine} from 'ReactCoroutine';\nimport type {Fiber} from 'ReactFiber';\nimport type {HostContext} from 'ReactFiberHostContext';\nimport type {FiberRoot} from 'ReactFiberRoot';\nimport type {HostConfig} from 'ReactFiberReconciler';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\n\nvar {\n  mountChildFibersInPlace,\n  reconcileChildFibers,\n  reconcileChildFibersInPlace,\n  cloneChildFibers,\n} = require('ReactChildFiber');\nvar {\n  beginUpdateQueue,\n} = require('ReactFiberUpdateQueue');\nvar ReactTypeOfWork = require('ReactTypeOfWork');\nvar {\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged,\n  pushContextProvider,\n  pushTopLevelContextObject,\n  invalidateContextProvider,\n} = require('ReactFiberContext');\nvar {\n  IndeterminateComponent,\n  FunctionalComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  CoroutineComponent,\n  CoroutineHandlerPhase,\n  YieldComponent,\n  Fragment,\n} = ReactTypeOfWork;\nvar {\n  NoWork,\n  OffscreenPriority,\n} = require('ReactPriorityLevel');\nvar {\n  Placement,\n  ContentReset,\n  Err,\n  Ref,\n} = require('ReactTypeOfSideEffect');\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\nvar ReactFiberClassComponent = require('ReactFiberClassComponent');\nvar invariant = require('fbjs/lib/invariant');\n\nif (__DEV__) {\n  var ReactDebugCurrentFiber = require('ReactDebugCurrentFiber');\n  var {cancelWorkTimer} = require('ReactDebugFiberPerf');\n  var warning = require('fbjs/lib/warning');\n\n  var warnedAboutStatelessRefs = {};\n}\n\nmodule.exports = function<T, P, I, TI, PI, C, CX, PL>(\n  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,\n  hostContext: HostContext<C, CX>,\n  scheduleUpdate: (fiber: Fiber, priorityLevel: PriorityLevel) => void,\n  getPriorityContext: () => PriorityLevel,\n) {\n  const {\n    shouldSetTextContent,\n    useSyncScheduling,\n    shouldDeprioritizeSubtree,\n  } = config;\n\n  const {\n    pushHostContext,\n    pushHostContainer,\n  } = hostContext;\n\n  const {\n    adoptClassInstance,\n    constructClassInstance,\n    mountClassInstance,\n    resumeMountClassInstance,\n    updateClassInstance,\n  } = ReactFiberClassComponent(\n    scheduleUpdate,\n    getPriorityContext,\n    memoizeProps,\n    memoizeState,\n  );\n\n  function markChildAsProgressed(current, workInProgress, priorityLevel) {\n    // We now have clones. Let's store them as the currently progressed work.\n    workInProgress.progressedChild = workInProgress.child;\n    workInProgress.progressedPriority = priorityLevel;\n    if (current !== null) {\n      // We also store it on the current. When the alternate swaps in we can\n      // continue from this point.\n      current.progressedChild = workInProgress.progressedChild;\n      current.progressedPriority = workInProgress.progressedPriority;\n    }\n  }\n\n  function clearDeletions(workInProgress) {\n    workInProgress.progressedFirstDeletion = (workInProgress.progressedLastDeletion = null);\n  }\n\n  function transferDeletions(workInProgress) {\n    // Any deletions get added first into the effect list.\n    workInProgress.firstEffect = workInProgress.progressedFirstDeletion;\n    workInProgress.lastEffect = workInProgress.progressedLastDeletion;\n  }\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    const priorityLevel = workInProgress.pendingWorkPriority;\n    reconcileChildrenAtPriority(\n      current,\n      workInProgress,\n      nextChildren,\n      priorityLevel,\n    );\n  }\n\n  function reconcileChildrenAtPriority(\n    current,\n    workInProgress,\n    nextChildren,\n    priorityLevel,\n  ) {\n    // At this point any memoization is no longer valid since we'll have changed\n    // the children.\n    workInProgress.memoizedProps = null;\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibersInPlace(\n        workInProgress,\n        workInProgress.child,\n        nextChildren,\n        priorityLevel,\n      );\n    } else if (current.child === workInProgress.child) {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      clearDeletions(workInProgress);\n\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        workInProgress.child,\n        nextChildren,\n        priorityLevel,\n      );\n\n      transferDeletions(workInProgress);\n    } else {\n      // If, on the other hand, it is already using a clone, that means we've\n      // already begun some work on this tree and we can continue where we left\n      // off by reconciling against the existing children.\n      workInProgress.child = reconcileChildFibersInPlace(\n        workInProgress,\n        workInProgress.child,\n        nextChildren,\n        priorityLevel,\n      );\n\n      transferDeletions(workInProgress);\n    }\n    markChildAsProgressed(current, workInProgress, priorityLevel);\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (\n      nextChildren === null || workInProgress.memoizedProps === nextChildren\n    ) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current: Fiber | null, workInProgress: Fiber) {\n    const ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    const memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: Disable this before release, since it is not part of the public API\n      // I use this for testing to compare the relative overhead of classes.\n      if (\n        typeof fn.shouldComponentUpdate === 'function' &&\n        !fn.shouldComponentUpdate(memoizedProps, nextProps)\n      ) {\n        // Memoize props even if shouldComponentUpdate returns false\n        memoizeProps(workInProgress, nextProps);\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    if (__DEV__) {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.phase = 'render';\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.phase = null;\n    } else {\n      nextChildren = fn(nextProps, context);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    const hasContext = pushContextProvider(workInProgress);\n\n    let shouldUpdate;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress);\n        mountClassInstance(workInProgress, priorityLevel);\n        shouldUpdate = true;\n      } else {\n        // In a resume, we'll already have an instance we can reuse.\n        shouldUpdate = resumeMountClassInstance(workInProgress, priorityLevel);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(\n        current,\n        workInProgress,\n        priorityLevel,\n      );\n    }\n    return finishClassComponent(\n      current,\n      workInProgress,\n      shouldUpdate,\n      hasContext,\n    );\n  }\n\n  function finishClassComponent(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    shouldUpdate: boolean,\n    hasContext: boolean,\n  ) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    const instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    let nextChildren;\n    if (__DEV__) {\n      ReactDebugCurrentFiber.phase = 'render';\n      nextChildren = instance.render();\n      ReactDebugCurrentFiber.phase = null;\n    } else {\n      nextChildren = instance.render();\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress);\n    }\n    return workInProgress.child;\n  }\n\n  function updateHostRoot(current, workInProgress, priorityLevel) {\n    const root = (workInProgress.stateNode: FiberRoot);\n    if (root.pendingContext) {\n      pushTopLevelContextObject(\n        workInProgress,\n        root.pendingContext,\n        root.pendingContext !== root.context,\n      );\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n\n    pushHostContainer(workInProgress, root.containerInfo);\n\n    const updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      const prevState = workInProgress.memoizedState;\n      const state = beginUpdateQueue(\n        workInProgress,\n        updateQueue,\n        null,\n        prevState,\n        null,\n        priorityLevel,\n      );\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work matching this priority.\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      const element = state.element;\n      reconcileChildren(current, workInProgress, element);\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress) {\n    pushHostContext(workInProgress);\n\n    let nextProps = workInProgress.pendingProps;\n    const prevProps = current !== null ? current.memoizedProps : null;\n    const memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n        invariant(\n          nextProps !== null,\n          'We should always have pending or current props. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      if (\n        !useSyncScheduling &&\n        shouldDeprioritizeSubtree(workInProgress.type, memoizedProps) &&\n        workInProgress.pendingWorkPriority !== OffscreenPriority\n      ) {\n        // This subtree still has work, but it should be deprioritized so we need\n        // to bail out and not do any work yet.\n        // TODO: It would be better if this tree got its correct priority set\n        // during scheduleUpdate instead because otherwise we'll start a higher\n        // priority reconciliation first before we can get down here. However,\n        // that is a bit tricky since workInProgress and current can have\n        // different \"hidden\" settings.\n        let child = workInProgress.progressedChild;\n        while (child !== null) {\n          // To ensure that this subtree gets its priority reset, the children\n          // need to be reset.\n          child.pendingWorkPriority = OffscreenPriority;\n          child = child.sibling;\n        }\n        return null;\n      }\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    let nextChildren = nextProps.children;\n    const isDirectTextChild = shouldSetTextContent(nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    if (\n      !useSyncScheduling &&\n      shouldDeprioritizeSubtree(workInProgress.type, nextProps) &&\n      workInProgress.pendingWorkPriority !== OffscreenPriority\n    ) {\n      // If this host component is hidden, we can bail out on the children.\n      // We'll rerender the children later at the lower priority.\n\n      // It is unfortunate that we have to do the reconciliation of these\n      // children already since that will add them to the tree even though\n      // they are not actually done yet. If this is a large set it is also\n      // confusing that this takes time to do right now instead of later.\n\n      if (workInProgress.progressedPriority === OffscreenPriority) {\n        // If we already made some progress on the offscreen priority before,\n        // then we should continue from where we left off.\n        workInProgress.child = workInProgress.progressedChild;\n      }\n\n      // Reconcile the children and stash them for later work.\n      reconcileChildrenAtPriority(\n        current,\n        workInProgress,\n        nextChildren,\n        OffscreenPriority,\n      );\n      memoizeProps(workInProgress, nextProps);\n      workInProgress.child = current !== null ? current.child : null;\n\n      if (current === null) {\n        // If this doesn't have a current we won't track it for placement\n        // effects. However, when we come back around to this we have already\n        // inserted the parent which means that we'll infact need to make this a\n        // placement.\n        // TODO: There has to be a better solution to this problem.\n        let child = workInProgress.progressedChild;\n        while (child !== null) {\n          child.effectTag = Placement;\n          child = child.sibling;\n        }\n      }\n\n      // Abort and don't process children yet.\n      return null;\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextProps);\n      return workInProgress.child;\n    }\n  }\n\n  function updateHostText(current, workInProgress) {\n    let nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, priorityLevel) {\n    invariant(\n      current === null,\n      'An indeterminate component should never have mounted. This error is ' +\n        'likely caused by a bug in React. Please file an issue.',\n    );\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    if (__DEV__) {\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    } else {\n      value = fn(props, context);\n    }\n\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      typeof value.render === 'function'\n    ) {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      const hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, priorityLevel);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      if (__DEV__) {\n        const Component = workInProgress.type;\n\n        if (Component) {\n          warning(\n            !Component.childContextTypes,\n            '%s(...): childContextTypes cannot be defined on a functional component.',\n            Component.displayName || Component.name || 'Component',\n          );\n        }\n        if (workInProgress.ref !== null) {\n          let info = '';\n          const ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          let warningKey = ownerName || workInProgress._debugID || '';\n          const debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(\n              false,\n              'Stateless function components cannot be given refs. ' +\n                'Attempts to access this ref will fail.%s%s',\n              info,\n              ReactDebugCurrentFiber.getCurrentFiberStackAddendum(),\n            );\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCoroutineComponent(current, workInProgress) {\n    var nextCoroutine = (workInProgress.pendingProps: null | ReactCoroutine);\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCoroutine === null) {\n        nextCoroutine = current && current.memoizedProps;\n        invariant(\n          nextCoroutine !== null,\n          'We should always have pending or current props. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    } else if (\n      nextCoroutine === null || workInProgress.memoizedProps === nextCoroutine\n    ) {\n      nextCoroutine = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    const nextChildren = nextCoroutine.children;\n    const priorityLevel = workInProgress.pendingWorkPriority;\n\n    // The following is a fork of reconcileChildrenAtPriority but using\n    // stateNode to store the child.\n\n    // At this point any memoization is no longer valid since we'll have changed\n    // the children.\n    workInProgress.memoizedProps = null;\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibersInPlace(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        priorityLevel,\n      );\n    } else if (current.child === workInProgress.child) {\n      clearDeletions(workInProgress);\n\n      workInProgress.stateNode = reconcileChildFibers(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        priorityLevel,\n      );\n\n      transferDeletions(workInProgress);\n    } else {\n      workInProgress.stateNode = reconcileChildFibersInPlace(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        priorityLevel,\n      );\n\n      transferDeletions(workInProgress);\n    }\n\n    memoizeProps(workInProgress, nextCoroutine);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    const priorityLevel = workInProgress.pendingWorkPriority;\n    let nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        invariant(\n          nextChildren != null,\n          'We should always have pending or current props. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    } else if (\n      nextChildren === null || workInProgress.memoizedProps === nextChildren\n    ) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibersInPlace(\n        workInProgress,\n        workInProgress.child,\n        nextChildren,\n        priorityLevel,\n      );\n      memoizeProps(workInProgress, nextChildren);\n      markChildAsProgressed(current, workInProgress, priorityLevel);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(\n    current,\n    workInProgress: Fiber,\n  ): Fiber | null {\n    if (__DEV__) {\n      cancelWorkTimer(workInProgress);\n    }\n\n    const priorityLevel = workInProgress.pendingWorkPriority;\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    if (current && workInProgress.child === current.child) {\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      clearDeletions(workInProgress);\n    }\n\n    cloneChildFibers(current, workInProgress);\n    markChildAsProgressed(current, workInProgress, priorityLevel);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    if (__DEV__) {\n      cancelWorkTimer(workInProgress);\n    }\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo,\n        );\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  function memoizeProps(workInProgress: Fiber, nextProps: any) {\n    workInProgress.memoizedProps = nextProps;\n    // Reset the pending props\n    workInProgress.pendingProps = null;\n  }\n\n  function memoizeState(workInProgress: Fiber, nextState: any) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by beginUpdateQueue.\n  }\n\n  function beginWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ): Fiber | null {\n    if (\n      workInProgress.pendingWorkPriority === NoWork ||\n      workInProgress.pendingWorkPriority > priorityLevel\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = workInProgress;\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (workInProgress.progressedPriority === priorityLevel) {\n      // If we have progressed work on this priority level already, we can\n      // proceed this that as the child.\n      workInProgress.child = workInProgress.progressedChild;\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(\n          current,\n          workInProgress,\n          priorityLevel,\n        );\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, priorityLevel);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, priorityLevel);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CoroutineHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CoroutineComponent;\n      // Intentionally fall through since this is now the same.\n      case CoroutineComponent:\n        return updateCoroutineComponent(current, workInProgress);\n      case YieldComponent:\n        // A yield component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(\n          false,\n          'Unknown unit of work tag. This error is likely caused by a bug in ' +\n            'React. Please file an issue.',\n        );\n    }\n  }\n\n  function beginFailedWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ) {\n    invariant(\n      workInProgress.tag === ClassComponent || workInProgress.tag === HostRoot,\n      'Invalid type of work. This error is likely caused by a bug in React. ' +\n        'Please file an issue.',\n    );\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    if (\n      workInProgress.pendingWorkPriority === NoWork ||\n      workInProgress.pendingWorkPriority > priorityLevel\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    const nextChildren = null;\n    reconcileChildren(current, workInProgress, nextChildren);\n\n    if (workInProgress.tag === ClassComponent) {\n      const instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n      workInProgress.pendingProps = null;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork,\n    beginFailedWork,\n  };\n};\n"]}]