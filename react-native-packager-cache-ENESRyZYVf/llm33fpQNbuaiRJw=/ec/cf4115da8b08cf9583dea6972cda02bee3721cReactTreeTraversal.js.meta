["25c8adace330c226215735ef1b4781184aa788e9","5a9ed04015ecb3e266fe1c1dfd8c63f68cef98f0",["ReactTypeOfWork"],[40],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/shared/ReactTreeTraversal.js"],"names":["require","HostComponent","getParent","inst","_hostParent","undefined","tag","return","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","push","i","length","traverseEnterLeave","from","to","argFrom","argTo","common","pathFrom","pathTo","module","exports"],"mappings":";;AAWA;;eAEsBA,QAAQ,iBAAR,C;IAAjBC,a,YAAAA,a;;AAEL,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,MAAIA,KAAKC,WAAL,KAAqBC,SAAzB,EAAoC;AAClC,WAAOF,KAAKC,WAAZ;AACD;AACD,MAAI,OAAOD,KAAKG,GAAZ,KAAoB,QAAxB,EAAkC;AAChC,OAAG;AACDH,aAAOA,KAAKI,MAAZ;AAMD,KAPD,QAOSJ,QAAQA,KAAKG,GAAL,KAAaL,aAP9B;AAQA,QAAIE,IAAJ,EAAU;AACR,aAAOA,IAAP;AACD;AACF;AACD,SAAO,IAAP;AACD;;AAMD,SAASK,uBAAT,CAAiCC,KAAjC,EAAwCC,KAAxC,EAA+C;AAC7C,MAAIC,SAAS,CAAb;AACA,OAAK,IAAIC,QAAQH,KAAjB,EAAwBG,KAAxB,EAA+BA,QAAQV,UAAUU,KAAV,CAAvC,EAAyD;AACvDD;AACD;AACD,MAAIE,SAAS,CAAb;AACA,OAAK,IAAIC,QAAQJ,KAAjB,EAAwBI,KAAxB,EAA+BA,QAAQZ,UAAUY,KAAV,CAAvC,EAAyD;AACvDD;AACD;;AAGD,SAAOF,SAASE,MAAT,GAAkB,CAAzB,EAA4B;AAC1BJ,YAAQP,UAAUO,KAAV,CAAR;AACAE;AACD;;AAGD,SAAOE,SAASF,MAAT,GAAkB,CAAzB,EAA4B;AAC1BD,YAAQR,UAAUQ,KAAV,CAAR;AACAG;AACD;;AAGD,MAAIE,QAAQJ,MAAZ;AACA,SAAOI,OAAP,EAAgB;AACd,QAAIN,UAAUC,KAAV,IAAmBD,UAAUC,MAAMM,SAAvC,EAAkD;AAChD,aAAOP,KAAP;AACD;AACDA,YAAQP,UAAUO,KAAV,CAAR;AACAC,YAAQR,UAAUQ,KAAV,CAAR;AACD;AACD,SAAO,IAAP;AACD;;AAKD,SAASO,UAAT,CAAoBR,KAApB,EAA2BC,KAA3B,EAAkC;AAChC,SAAOA,KAAP,EAAc;AACZ,QAAID,UAAUC,KAAV,IAAmBD,UAAUC,MAAMM,SAAvC,EAAkD;AAChD,aAAO,IAAP;AACD;AACDN,YAAQR,UAAUQ,KAAV,CAAR;AACD;AACD,SAAO,KAAP;AACD;;AAKD,SAASQ,iBAAT,CAA2Bf,IAA3B,EAAiC;AAC/B,SAAOD,UAAUC,IAAV,CAAP;AACD;;AAKD,SAASgB,gBAAT,CAA0BhB,IAA1B,EAAgCiB,EAAhC,EAAoCC,GAApC,EAAyC;AACvC,MAAIC,OAAO,EAAX;AACA,SAAOnB,IAAP,EAAa;AACXmB,SAAKC,IAAL,CAAUpB,IAAV;AACAA,WAAOD,UAAUC,IAAV,CAAP;AACD;AACD,MAAIqB,CAAJ;AACA,OAAKA,IAAIF,KAAKG,MAAd,EAAsBD,MAAM,CAA5B,GAAiC;AAC/BJ,OAAGE,KAAKE,CAAL,CAAH,EAAY,UAAZ,EAAwBH,GAAxB;AACD;AACD,OAAKG,IAAI,CAAT,EAAYA,IAAIF,KAAKG,MAArB,EAA6BD,GAA7B,EAAkC;AAChCJ,OAAGE,KAAKE,CAAL,CAAH,EAAY,SAAZ,EAAuBH,GAAvB;AACD;AACF;;AASD,SAASK,kBAAT,CAA4BC,IAA5B,EAAkCC,EAAlC,EAAsCR,EAAtC,EAA0CS,OAA1C,EAAmDC,KAAnD,EAA0D;AACxD,MAAIC,SAASJ,QAAQC,EAAR,GAAapB,wBAAwBmB,IAAxB,EAA8BC,EAA9B,CAAb,GAAiD,IAA9D;AACA,MAAII,WAAW,EAAf;AACA,SAAOL,QAAQA,SAASI,MAAxB,EAAgC;AAC9BC,aAAST,IAAT,CAAcI,IAAd;AACAA,WAAOzB,UAAUyB,IAAV,CAAP;AACD;AACD,MAAIM,SAAS,EAAb;AACA,SAAOL,MAAMA,OAAOG,MAApB,EAA4B;AAC1BE,WAAOV,IAAP,CAAYK,EAAZ;AACAA,SAAK1B,UAAU0B,EAAV,CAAL;AACD;AACD,MAAIJ,CAAJ;AACA,OAAKA,IAAI,CAAT,EAAYA,IAAIQ,SAASP,MAAzB,EAAiCD,GAAjC,EAAsC;AACpCJ,OAAGY,SAASR,CAAT,CAAH,EAAgB,SAAhB,EAA2BK,OAA3B;AACD;AACD,OAAKL,IAAIS,OAAOR,MAAhB,EAAwBD,MAAM,CAA9B,GAAmC;AACjCJ,OAAGa,OAAOT,CAAP,CAAH,EAAc,UAAd,EAA0BM,KAA1B;AACD;AACF;;AAEDI,OAAOC,OAAP,GAAiB;AACflB,cAAYA,UADG;AAEfT,2BAAyBA,uBAFV;AAGfU,qBAAmBA,iBAHJ;AAIfC,oBAAkBA,gBAJH;AAKfO,sBAAoBA;AALL,CAAjB","sourcesContent":["/**\n * Copyright 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTreeTraversal\n */\n\n'use strict';\n\nvar {HostComponent} = require('ReactTypeOfWork');\n\nfunction getParent(inst) {\n  if (inst._hostParent !== undefined) {\n    return inst._hostParent;\n  }\n  if (typeof inst.tag === 'number') {\n    do {\n      inst = inst.return;\n      // TODO: If this is a HostRoot we might want to bail out.\n      // That is depending on if we want nested subtrees (layers) to bubble\n      // events to their parent. We could also go through parentNode on the\n      // host node but that wouldn't work for React Native and doesn't let us\n      // do the portal feature.\n    } while (inst && inst.tag !== HostComponent);\n    if (inst) {\n      return inst;\n    }\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (from && from !== common) {\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (to && to !== common) {\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  var i;\n  for (i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (i = pathTo.length; i-- > 0; ) {\n    fn(pathTo[i], 'captured', argTo);\n  }\n}\n\nmodule.exports = {\n  isAncestor: isAncestor,\n  getLowestCommonAncestor: getLowestCommonAncestor,\n  getParentInstance: getParentInstance,\n  traverseTwoPhase: traverseTwoPhase,\n  traverseEnterLeave: traverseEnterLeave,\n};\n"]}]