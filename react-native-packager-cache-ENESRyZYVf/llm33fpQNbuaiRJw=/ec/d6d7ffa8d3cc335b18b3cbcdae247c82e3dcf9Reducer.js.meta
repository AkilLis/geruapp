["3b8d1d49ec1eb9f8218ed059261101410304f92c","a0b8a3816fd1969414fea7d611404b689f223fcb",["react-native","lodash.isequal","./ActionConst","./Actions","./Util","./State"],[161,201,309,421,456,489],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native-router-flux/src/Reducer.js"],"names":["findElement","getCurrent","ActionConst","checkPropertiesEqual","action","lastAction","Object","keys","key","indexOf","resetHistoryStack","state","newState","children","index","i","length","el","initial","tabs","refreshTopChild","refresh","topChild","slice","inject","props","scenes","condition","type","REFRESH","sceneKey","parent","res","map","changed","changedIndex","ind","POP_TO","targetIndex","BACK","BACK_ACTION","popNum","from","ANDROID_BACK","OS","POP_AND_REPLACE","newAction","duration","newProps","base","navBar","rootProps","PUSH_OR_POP","findIndex","PUSH","clone","JUMP","forEach","c","activeChild","incomingChild","incomingChildHadTabs","incomingChildWasActive","activeChildIsIncomingChild","parentIndex","unmountScenes","rState","REPLACE","RESET","splice","child","current","update","reducer","initialState","stateParam","actionParam","evaluated","scene","target","data","targetEl","targetParent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-param-reassign */\n\nimport { Platform } from 'react-native';\nimport isEqual from 'lodash.isequal';\nimport * as ActionConst from './ActionConst';\nimport { ActionMap } from './Actions';\nimport { assert } from './Util';\nimport { getInitialState } from './State';\n\nfunction checkPropertiesEqual(action, lastAction) {\n  for (const key of Object.keys(action)) {\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (!isEqual(action[key], lastAction[key]) && (typeof action[key] !== 'function') && (typeof lastAction[key] !== 'function')) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction resetHistoryStack(state) {\n  const newState = state;\n\n  if (newState.children) {\n    newState.index = 0;\n\n    let i;\n    for (i = 0; i < newState.children.length; i += 1) {\n      const el = newState.children[i];\n\n      if (el.initial) {\n        newState.index = i;\n\n        if (!newState.tabs) {\n          newState.children = [resetHistoryStack(el)];\n        } else {\n          newState.children[i] = resetHistoryStack(el);\n        }\n      } else {\n        newState.children[i] = resetHistoryStack(el);\n      }\n    }\n  }\n  return newState;\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    const topChild = children[children.length - 1];\n    return [...children.slice(0, -1), { ...topChild, ...refresh }];\n  }\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  const condition = ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key ||\n    state.sceneKey === action.key : state.sceneKey === props.parent;\n  // console.log(\"INJECT:\", action.key, state.sceneKey, condition);\n  if (!condition) {\n    if (state.children) {\n      const res = state.children.map(el => inject(el, action, props, scenes));\n      let changed = false;\n      let changedIndex = -1;\n      for (let i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n      return changed ? { ...state, children: res, index: changedIndex } : state;\n    }\n    return state;\n  }\n  let ind;\n\n  switch (ActionMap[action.type]) {\n    case ActionConst.POP_TO: {\n      const targetIndex = action.targetIndex;\n\n      return {\n        ...state,\n        index: targetIndex,\n        children: refreshTopChild(state.children.slice(0, (targetIndex + 1)), action.refresh),\n      };\n    }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n      if (state.index === 0) {\n        return state;\n      }\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      return {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh),\n      };\n    }\n    case ActionConst.ANDROID_BACK: {\n      if (Platform.OS === 'android') {\n        assert(state.index > 0, 'You are already in the root scene.');\n      }\n\n      return {\n        ...state,\n        index: state.index - 1,\n        from: state.children[state.children.length - 1],\n        children: refreshTopChild(state.children.slice(0, -1), action.refresh),\n      };\n    }\n    // This action will pop the scene stack and then replace current scene in one go\n    case ActionConst.POP_AND_REPLACE: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n      assert(state.index > 0, 'You are already in the root scene.');\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      state = {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: state.children.slice(0, -1 * popNum),\n      };\n\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      const newAction = {\n        duration: 0,  // do not animate\n        ...action,\n      };\n      delete newAction.popNum;\n\n      const newProps = { ...props };\n      delete newProps.popNum;\n\n      state.children[state.children.length - 1] = getInitialState(\n        newProps,\n        scenes,\n        state.index,\n        newAction,\n      );\n\n      return { ...state, children: state.children };\n    }\n    case ActionConst.REFRESH:\n      return props.base ? {\n        navBar: state.navBar,\n        ...scenes.rootProps,\n        ...props,\n        key: state.key,\n        from: null,\n      }\n        : {\n          ...state,\n          ...props,\n          key: state.key,\n          from: null,\n        };\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(el => el.sceneKey === action.key);\n      if (ind !== -1) {\n        return {\n          ...state,\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh),\n        };\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone\n        && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.JUMP: {\n      assert(state.tabs, `Parent=${state.key} is not tab bar, jump action is not valid`);\n      ind = -1;\n      state.children.forEach((c, i) => { if (c.sceneKey === action.key) { ind = i; } });\n      assert(ind !== -1, `Cannot find route with key=${action.key} for parent=${state.key}`);\n\n      const activeChild = state.children[state.index];\n      const incomingChild = state.children[ind];\n\n      const incomingChildHadTabs = incomingChild.tabs;\n      const incomingChildWasActive = incomingChild.children.length > 1;\n      const activeChildIsIncomingChild = activeChild.sceneKey === action.key;\n      if (incomingChildHadTabs || !incomingChildWasActive || activeChildIsIncomingChild) {\n        state.children[ind] = getInitialState(\n          { ...props },\n          scenes,\n          state.index,\n          { ...action, parentIndex: state.children[ind].parentIndex },\n        );\n      }\n      \n      if (action.unmountScenes) {\n        const rState = resetHistoryStack(state);\n        return { ...rState, index: ind };\n      }\n\n      return { ...state, index: ind };\n    }\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, children: state.children };\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = getInitialState(props, scenes, 0, action);\n\n      return {\n        ...state,\n        index: 0,\n        from: null,\n        children: state.children,\n      };\n    default:\n      return state;\n  }\n}\n\nexport function findElement(state, key, type) {\n  if ((ActionMap[type] === ActionConst.REFRESH && state.key === key) || state.sceneKey === key) {\n    return state;\n  }\n  if (state.children) {\n    for (const child of state.children) {\n      const current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n  return null;\n}\n\nexport function getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  // find parent in the state\n  const props = { ...state.scenes[action.key], ...action };\n  assert(props.parent, `No parent is defined for route=${action.key}`);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer({ initialState, scenes }) {\n  assert(initialState, 'initialState should not be null');\n  assert(initialState.key, 'initialState.key should not be null');\n  assert(scenes, 'scenes should not be null');\n  return (stateParam, actionParam) => {\n    let state = stateParam;\n    let action = actionParam;\n    state = state || { ...initialState, scenes };\n    assert(action, 'action should be defined');\n    assert(action.type, 'action type should be defined');\n    assert(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (ActionMap[action.type] === ActionConst.REFRESH) {\n        let key = action.key;\n        let child = findElement(state, key, action.type) || state.scenes[key];\n        let sceneKey = child.sceneKey;\n        if (child.base) {\n          child = { ...state.scenes[child.base], ...child };\n          assert(state.scenes[child.base], `No scene exists for base=${child.base}`);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n        assert(child, `missed child data for key=${key}`);\n        // evaluate functions within actions to allow conditional set, like switch values\n        const evaluated = {};\n        Object.keys(action).forEach((el) => {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined'\n            && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = { ...child, ...action, ...evaluated, sceneKey, key };\n\n        // console.log(\"REFRESH ACTION:\", action);\n      } else {\n        const scene = state.scenes[action.key];\n        assert(scene, `missed route data for key=${action.key}`);\n        // clone scene\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      // set current route for pop action or refresh action\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n        ActionMap[action.type] === ActionConst.BACK ||\n        ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n        ActionMap[action.type] === ActionConst.POP_AND_REPLACE ||\n        ActionMap[action.type] === ActionConst.REFRESH ||\n        ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = { ...getCurrent(state), ...action };\n        }\n      }\n\n      // Find the parent and index of the future state\n      if (ActionMap[action.type] === ActionConst.POP_TO) {\n        /*\n         * if a string is passed as only argument\n         * Actions.filterParam will put it in the data property\n         * otherwise look for the scene property\n         */\n        const target = action.data || action.scene;\n        assert(target, 'PopTo() must be called with a single argument: ' +\n          'either the scene name (string) or an object with within the scene property ' +\n          'carrying the target scene to pop to');\n\n        const targetEl = findElement(state, target, action.type);\n        assert(targetEl, `Cannot find element name named ${target} within current state`);\n\n        // target is a node\n        let parent = targetEl.sceneKey;\n        let targetIndex = 0;\n\n        // target is child of a node\n        if (!targetEl.children) {\n          const targetParent = findElement(state, targetEl.parent, action.type);\n          assert(targetParent, `Cannot find parent for target ${target}`);\n          parent = targetParent.sceneKey;\n\n          targetIndex = targetParent.children.indexOf(targetEl);\n          assert(targetIndex > -1, `${target} does not belong to ${targetParent.sceneKey}`);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      // recursive pop parent\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n        ActionMap[action.type] === ActionConst.BACK ||\n        ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n        ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        const parent = action.parent || state.scenes[action.key].parent;\n        let el = findElement(state, parent, action.type);\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          assert(el, `Cannot find element for parent=${el.parent} within current state`);\n        }\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n\n    }\n  };\n}\n\nexport default reducer;\n"]}]