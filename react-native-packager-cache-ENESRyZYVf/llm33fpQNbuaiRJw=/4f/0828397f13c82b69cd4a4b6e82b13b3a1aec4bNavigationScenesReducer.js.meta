["6a7a73d57b625a4e45ba0be6be87e1057ec6133e","1a2689ade2343560388307204e31fe3fb59bb457",["fbjs/lib/invariant"],[40],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native-experimental-navigation/NavigationScenesReducer.js"],"names":["invariant","require","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","navigationState","NavigationScenesReducer","scenes","nextState","prevState","prevScenes","Map","freshScenes","staleScenes","forEach","scene","set","nextKeys","Set","children","has","add","delete","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule NavigationScenesReducer\n * @flow\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\nimport type {\n  NavigationParentState,\n  NavigationScene,\n} from 'NavigationTypeDefinition';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string): number {\n  var delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(\n  one: NavigationScene,\n  two: NavigationScene,\n): number {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(\n    one.key,\n    two.key,\n  );\n}\n\nfunction areScenesShallowEqual(\n  one: NavigationScene,\n  two: NavigationScene,\n): boolean {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.navigationState === two.navigationState &&\n    one.navigationState.key === two.navigationState.key\n  );\n}\n\nfunction NavigationScenesReducer(\n  scenes: Array<NavigationScene>,\n  nextState: NavigationParentState,\n  prevState: ?NavigationParentState,\n): Array<NavigationScene> {\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const {key} = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  nextState.children.forEach((navigationState, index) => {\n    const key = SCENE_KEY_PREFIX + navigationState.key;\n    const scene = {\n      index,\n      isStale: false,\n      key,\n      navigationState,\n    };\n    invariant(\n      !nextKeys.has(key),\n      `navigationState.children[${index}].key \"${key}\" conflicts with` +\n        'another child!'\n    );\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    // Look at the previous children and classify any removed scenes as `stale`.\n    prevState.children.forEach((navigationState, index) => {\n      const key = SCENE_KEY_PREFIX + navigationState.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      staleScenes.set(key, {\n        index,\n        isStale: true,\n        key,\n        navigationState,\n      });\n    });\n  }\n\n  const nextScenes = [];\n\n  const mergeScene = (nextScene => {\n    const {key} = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  });\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  return nextScenes.sort(compareScenes);\n}\n\nmodule.exports = NavigationScenesReducer;\n"]}]