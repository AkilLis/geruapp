["534d705470057e24c9d01af5fa0b2416cb331cb5","c2611688d9d04fe9883c5e8d60f9dbe1548cfcef",["EventPluginUtils","EventPropagators","ReactTreeTraversal","ResponderSyntheticEvent","ResponderTouchHistoryStore","accumulate"],[48,100,154,215,284,341],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/shared/event/eventPlugins/ResponderEventPlugin.js"],"names":["EventPluginUtils","require","EventPropagators","ReactTreeTraversal","ResponderSyntheticEvent","ResponderTouchHistoryStore","accumulate","isStartish","isMoveish","isEndish","executeDirectDispatch","hasDispatches","executeDispatchesInOrderStopAtTrue","responderInst","trackedTouchCount","previousActiveTouches","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes","startShouldSetResponder","phasedRegistrationNames","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","registrationName","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","topLevelType","targetInst","nativeEvent","nativeEventTarget","shouldSetEventType","bubbleShouldSetFrom","getLowestCommonAncestor","skipOverBubbleShouldSetFrom","shouldSetEvent","getPooled","touchHistory","accumulateTwoPhaseDispatchesSkipTarget","accumulateTwoPhaseDispatches","wantsResponderInst","isPersistent","constructor","release","extracted","grantEvent","accumulateDirectDispatches","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","touches","length","i","activeTouch","target","undefined","getInstanceFromNode","isAncestor","_getResponder","extractEvents","console","error","recordTouchTrack","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","numberActiveTouches","GlobalInteractionHandler","injection","injectGlobalResponderHandler","injectGlobalInteractionHandler","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ResponderEventPlugin\n */\n\n'use strict';\n\nvar EventPluginUtils = require('EventPluginUtils');\nvar EventPropagators = require('EventPropagators');\nvar ReactTreeTraversal = require('ReactTreeTraversal');\nvar ResponderSyntheticEvent = require('ResponderSyntheticEvent');\nvar ResponderTouchHistoryStore = require('ResponderTouchHistoryStore');\n\nvar accumulate = require('accumulate');\n\nvar isStartish = EventPluginUtils.isStartish;\nvar isMoveish = EventPluginUtils.isMoveish;\nvar isEndish = EventPluginUtils.isEndish;\nvar executeDirectDispatch = EventPluginUtils.executeDirectDispatch;\nvar hasDispatches = EventPluginUtils.hasDispatches;\nvar executeDispatchesInOrderStopAtTrue = EventPluginUtils.executeDispatchesInOrderStopAtTrue;\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder,\n    );\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onStartShouldSetResponder',\n      captured: 'onStartShouldSetResponderCapture',\n    },\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onScrollShouldSetResponder',\n      captured: 'onScrollShouldSetResponderCapture',\n    },\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelectionChangeShouldSetResponder',\n      captured: 'onSelectionChangeShouldSetResponderCapture',\n    },\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onMoveShouldSetResponder',\n      captured: 'onMoveShouldSetResponderCapture',\n    },\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {registrationName: 'onResponderStart'},\n  responderMove: {registrationName: 'onResponderMove'},\n  responderEnd: {registrationName: 'onResponderEnd'},\n  responderRelease: {registrationName: 'onResponderRelease'},\n  responderTerminationRequest: {\n    registrationName: 'onResponderTerminationRequest',\n  },\n  responderGrant: {registrationName: 'onResponderGrant'},\n  responderReject: {registrationName: 'onResponderReject'},\n  responderTerminate: {registrationName: 'onResponderTerminate'},\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget,\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes.startShouldSetResponder\n    : isMoveish(topLevelType)\n        ? eventTypes.moveShouldSetResponder\n        : topLevelType === 'topSelectionChange'\n            ? eventTypes.selectionChangeShouldSetResponder\n            : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : ReactTreeTraversal.getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget,\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    EventPropagators.accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget,\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  EventPropagators.accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget,\n    );\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    EventPropagators.accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `EventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === 'topScroll' && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === 'topSelectionChange') ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType));\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = EventPluginUtils.getInstanceFromNode(target);\n      if (ReactTreeTraversal.isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          'Ended a touch event which was not counted in `trackedTouchCount`.',\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget,\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes.responderStart\n      : isResponderTouchMove\n          ? eventTypes.responderMove\n          : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderInst &&\n      topLevelType === 'topTouchCancel';\n    var isResponderRelease = responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes.responderTerminate\n      : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget,\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      EventPropagators.accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (\n      ResponderEventPlugin.GlobalInteractionHandler &&\n      numberActiveTouches !== previousActiveTouches\n    ) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(\n        numberActiveTouches,\n      );\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function(GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    },\n  },\n};\n\nmodule.exports = ResponderEventPlugin;\n"]}]