["e764b4e16f15b5aa4ebcc0e9f70fdeb9d2df91ac","da28ea5fa4d8e2e464826cc2e6310841834fbb19",["./authConstants","react-native-router-flux","./AppAuthToken","underscore"],[1370,1428,1486,1522],{"version":3,"sources":["/var/www/geruapp/src/auth/authActions.js"],"names":["logoutState","registerState","loginState","forgotPasswordState","logoutRequest","logoutSuccess","logoutFailure","logout","onAuthFormFieldChange","signupRequest","signupSuccess","signupFailure","sessionTokenRequest","sessionTokenRequestSuccess","sessionTokenRequestFailure","deleteTokenRequest","deleteTokenRequestSuccess","deleteSessionToken","getSessionToken","saveSessionToken","signup","loginRequest","loginSuccess","loginFailure","login","resetPasswordRequest","resetPasswordSuccess","resetPasswordFailure","resetPassword","_","require","type","error","payload","dispatch","then","token","BackendFactory","InitialLoginForm","catch","field","value","json","isUndefined","Tabbar","console","log","storeSessionToken","username","email","password","Login"],"mappings":"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","sourcesContent":["/**\n * # authActions.js\n *\n * All the request actions have 3 variations, the request, a success\n * and a failure. They all follow the pattern that the request will\n * set the ```isFetching``` to true and the whether it's successful or\n * fails, setting it back to false.\n *\n */\n'use strict'\n\n/**\n * ## Imports\n *\n * The actions supported\n */\nimport {\n  SESSION_TOKEN_REQUEST,\n  SESSION_TOKEN_SUCCESS,\n  SESSION_TOKEN_FAILURE,\n\n  DELETE_TOKEN_REQUEST,\n  DELETE_TOKEN_SUCCESS,\n\n  LOGOUT,\n  REGISTER,\n  LOGIN,\n  FORGOT_PASSWORD,\n\n  LOGOUT_REQUEST,\n  LOGOUT_SUCCESS,\n  LOGOUT_FAILURE,\n\n  LOGIN_REQUEST,\n  LOGIN_SUCCESS,\n  LOGIN_FAILURE,\n\n  ON_AUTH_FORM_FIELD_CHANGE,\n  SIGNUP_REQUEST,\n  SIGNUP_SUCCESS,\n  SIGNUP_FAILURE,\n\n  RESET_PASSWORD_REQUEST,\n  RESET_PASSWORD_SUCCESS,\n  RESET_PASSWORD_FAILURE\n\n} from './authConstants'\n\n\nconst _ = require('underscore')\n\nimport {Actions} from 'react-native-router-flux'\nimport { appAuthToken } from './AppAuthToken'\n\nexport function logoutState () {\n  return {\n    type: LOGOUT\n  }\n}\nexport function registerState () {\n  return {\n    type: REGISTER\n  }\n}\n\nexport function loginState () {\n  return {\n    type: LOGIN\n  }\n}\n\nexport function forgotPasswordState () {\n  return {\n    type: FORGOT_PASSWORD\n  }\n}\n\n/**\n * ## Logout actions\n */\nexport function logoutRequest () {\n  return {\n    type: LOGOUT_REQUEST\n  }\n}\n\nexport function logoutSuccess () {\n  return {\n    type: LOGOUT_SUCCESS\n  }\n}\nexport function logoutFailure (error) {\n  return {\n    type: LOGOUT_FAILURE,\n    payload: error\n  }\n}\n/**\n * ## Login\n * After dispatching the logoutRequest, get the sessionToken\n *\n *\n * When the response is received and it's valid\n * change the state to register and finish the logout\n *\n * But if the call fails, like expired token or\n * no network connection, just send the failure\n *\n * And if you fail due to an invalid sessionToken, be sure\n * to delete it so the user can log in.\n *\n * How could there be an invalid sessionToken?  Maybe they\n * haven't used the app for a long time.  Or they used another\n * device and logged out there.\n */\nexport function logout () {\n  return dispatch => {\n    dispatch(logoutRequest())\n    return appAuthToken.getSessionToken()\n\n      .then((token) => {\n        return BackendFactory(token).logout()\n      })\n\n      .then(() => {\n        dispatch(loginState())\n        dispatch(logoutSuccess())\n        dispatch(deleteSessionToken())\n        Actions.InitialLoginForm()\n      })\n\n      .catch((error) => {\n        dispatch(loginState())\n        dispatch(logoutFailure(error))\n      })\n  }\n}\n/**\n * ## onAuthFormFieldChange\n * Set the payload so the reducer can work on it\n */\nexport function onAuthFormFieldChange (field, value) {\n  return {\n    type: ON_AUTH_FORM_FIELD_CHANGE,\n    payload: {field: field, value: value}\n  }\n}\n/**\n * ## Signup actions\n */\nexport function signupRequest () {\n  return {\n    type: SIGNUP_REQUEST\n  }\n}\nexport function signupSuccess (json) {\n  return {\n    type: SIGNUP_SUCCESS,\n    payload: json\n  }\n}\nexport function signupFailure (error) {\n  return {\n    type: SIGNUP_FAILURE,\n    payload: error\n  }\n}\n/**\n * ## SessionToken actions\n */\nexport function sessionTokenRequest () {\n  return {\n    type: SESSION_TOKEN_REQUEST\n  }\n}\nexport function sessionTokenRequestSuccess (token) {\n  return {\n    type: SESSION_TOKEN_SUCCESS,\n    payload: token\n  }\n}\nexport function sessionTokenRequestFailure (error) {\n  return {\n    type: SESSION_TOKEN_FAILURE,\n    payload: _.isUndefined(error) ? null : error\n  }\n}\n\n/**\n * ## DeleteToken actions\n */\nexport function deleteTokenRequest () {\n  return {\n    type: DELETE_TOKEN_REQUEST\n  }\n}\nexport function deleteTokenRequestSuccess () {\n  return {\n    type: DELETE_TOKEN_SUCCESS\n  }\n}\n\n/**\n * ## Delete session token\n *\n * Call the AppAuthToken deleteSessionToken\n */\nexport function deleteSessionToken () {\n  return dispatch => {\n    dispatch(deleteTokenRequest())\n    return appAuthToken.deleteSessionToken()\n      .then(() => {\n        dispatch(deleteTokenRequestSuccess())\n      })\n  }\n}\n/**\n * ## Token\n * If AppAuthToken has the sessionToken, the user is logged in\n * so set the state to logout.\n * Otherwise, the user will default to the login in screen.\n */\nexport function getSessionToken () {\n  return dispatch => {\n    dispatch(sessionTokenRequest())\n    return appAuthToken.getSessionToken()\n\n      .then((token) => {\n        if (token) {\n          dispatch(sessionTokenRequestSuccess(token))\n          dispatch(logoutState())\n          Actions.Tabbar()\n        } else {\n          console.log('InitialLoginForm sented')\n          dispatch(sessionTokenRequestFailure())\n          Actions.InitialLoginForm()\n        }\n      })\n\n      .catch((error) => {\n        dispatch(sessionTokenRequestFailure(error))\n        dispatch(loginState())\n        Actions.InitialLoginForm()\n      })\n  }\n}\n\n/**\n * ## saveSessionToken\n * @param {Object} response - to return to keep the promise chain\n * @param {Object} json - object with sessionToken\n */\nexport function saveSessionToken (json) {\n  return appAuthToken.storeSessionToken(json)\n}\n/**\n * ## signup\n * @param {string} username - name of user\n * @param {string} email - user's email\n * @param {string} password - user's password\n *\n * Call the server signup and if good, save the sessionToken,\n * set the state to logout and signal success\n *\n * Otherwise, dispatch the error so the user can see\n */\nexport function signup (username, email, password) {\n  return dispatch => {\n    dispatch(signupRequest())\n    return BackendFactory().signup({\n      username: username,\n      email: email,\n      password: password\n    })\n\n      .then((json) => {\n        return saveSessionToken(\n          Object.assign({}, json,\n            { username: username,\n              email: email\n            })\n          )\n          .then(() => {\n            dispatch(signupSuccess(\n              Object.assign({}, json,\n               { username: username,\n                 email: email\n               })\n            ))\n            dispatch(logoutState())\n            // navigate to Tabbar\n            Actions.Tabbar()\n          })\n      })\n      .catch((error) => {\n        dispatch(signupFailure(error))\n      })\n  }\n}\n\n/**\n * ## Login actions\n */\nexport function loginRequest () {\n  return {\n    type: LOGIN_REQUEST\n  }\n}\n\nexport function loginSuccess (json) {\n  return {\n    type: LOGIN_SUCCESS,\n    payload: json\n  }\n}\n\nexport function loginFailure (error) {\n  return {\n    type: LOGIN_FAILURE,\n    payload: error\n  }\n}\n/**\n * ## Login\n * @param {string} username - user's name\n * @param {string} password - user's password\n *\n * After calling Backend, if response is good, save the json\n * which is the currentUser which contains the sessionToken\n *\n * If successful, set the state to logout\n * otherwise, dispatch a failure\n */\n\nexport function login (username, password) {\n  return dispatch => {\n    dispatch(loginRequest())\n    Actions.Tabbar()\n  }\n\n  return dispatch => {\n    dispatch(loginRequest())\n    return BackendFactory().login({\n      username: username,\n      password: password\n    })\n\n      .then(function (json) {\n        return saveSessionToken(json)\n          .then(function () {\n            dispatch(loginSuccess(json))\n            // navigate to Tabbar\n            Actions.Tabbar()\n            dispatch(logoutState())\n          })\n      })\n      .catch((error) => {\n        dispatch(loginFailure(error))\n      })\n  }\n}\n\n/**\n * ## ResetPassword actions\n */\nexport function resetPasswordRequest () {\n  return {\n    type: RESET_PASSWORD_REQUEST\n  }\n}\n\nexport function resetPasswordSuccess () {\n  return {\n    type: RESET_PASSWORD_SUCCESS\n  }\n}\n\nexport function resetPasswordFailure (error) {\n  return {\n    type: RESET_PASSWORD_FAILURE,\n    payload: error\n  }\n}\n/**\n * ## ResetPassword\n *\n * @param {string} email - the email address to reset password\n * *Note* There's no feedback to the user whether the email\n * address is valid or not.\n *\n * This functionality depends on the server set\n * up correctly ie, that emails are verified.\n * With that enabled, an email can be sent w/ a\n * form for setting the new password.\n */\nexport function resetPassword (email) {\n  return dispatch => {\n    dispatch(resetPasswordRequest())\n    return BackendFactory().resetPassword({\n      email: email\n    })\n      .then(() => {\n        dispatch(loginState())\n        dispatch(resetPasswordSuccess())\n        Actions.Login()\n      })\n      .catch((error) => {\n        dispatch(resetPasswordFailure(error))\n      })\n  }\n}\n"]}]