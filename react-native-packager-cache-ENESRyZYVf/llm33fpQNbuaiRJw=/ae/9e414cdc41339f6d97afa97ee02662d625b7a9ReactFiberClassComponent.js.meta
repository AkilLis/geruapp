["82b5918c808156ac6058a125dd4435c38c6f279c","db453911c24f27b7f895c6e381849052c49319cd",["ReactTypeOfSideEffect","ReactFiberContext","ReactFiberUpdateQueue","ReactFiberTreeReflection","ReactInstanceMap","fbjs/lib/emptyObject","getComponentName","fbjs/lib/shallowEqual","fbjs/lib/invariant","ReactDebugFiberPerf","fbjs/lib/warning"],[40,121,370,607,707,805,852,908,956,1006,1101,1250],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberClassComponent.js"],"names":["require","Update","cacheContext","getMaskedContext","getUnmaskedContext","isContextConsumer","addUpdate","addReplaceUpdate","addForceUpdate","beginUpdateQueue","hasContextChanged","isMounted","ReactInstanceMap","emptyObject","getComponentName","shallowEqual","invariant","isArray","Array","__DEV__","startPhaseTimer","stopPhaseTimer","warning","warnOnInvalidCallback","callback","callerName","module","exports","scheduleUpdate","getPriorityContext","memoizeProps","memoizeState","updater","enqueueSetState","instance","partialState","fiber","get","priorityLevel","undefined","enqueueReplaceState","state","enqueueForceUpdate","checkShouldComponentUpdate","workInProgress","oldProps","newProps","oldState","newState","newContext","updateQueue","hasForceUpdate","stateNode","shouldComponentUpdate","shouldUpdate","type","prototype","isPureReactComponent","checkClassInstance","name","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","contextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","props","pendingProps","getChildContext","childContextTypes","resetInputPointers","memoizedProps","memoizedState","adoptClassInstance","set","constructClassInstance","ctor","unmaskedContext","needsContext","context","mountClassInstance","refs","componentWillMount","componentDidMount","effectTag","resumeMountClassInstance","newUnmaskedContext","newInstance","newUpdateQueue","updateClassInstance","current","oldContext","componentWillReceiveProps","componentDidUpdate","componentWillUpdate"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberClassComponent\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\n\nvar {\n  Update,\n} = require('ReactTypeOfSideEffect');\nvar {\n  cacheContext,\n  getMaskedContext,\n  getUnmaskedContext,\n  isContextConsumer,\n} = require('ReactFiberContext');\nvar {\n  addUpdate,\n  addReplaceUpdate,\n  addForceUpdate,\n  beginUpdateQueue,\n} = require('ReactFiberUpdateQueue');\nvar {hasContextChanged} = require('ReactFiberContext');\nvar {isMounted} = require('ReactFiberTreeReflection');\nvar ReactInstanceMap = require('ReactInstanceMap');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar getComponentName = require('getComponentName');\nvar shallowEqual = require('fbjs/lib/shallowEqual');\nvar invariant = require('fbjs/lib/invariant');\n\nconst isArray = Array.isArray;\n\nif (__DEV__) {\n  var {\n    startPhaseTimer,\n    stopPhaseTimer,\n  } = require('ReactDebugFiberPerf');\n  var warning = require('fbjs/lib/warning');\n  var warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    warning(\n      callback === null || typeof callback === 'function',\n      '%s(...): Expected the last optional `callback` argument to be a ' +\n        'function. Instead received: %s.',\n      callerName,\n      callback,\n    );\n  };\n}\n\nmodule.exports = function(\n  scheduleUpdate: (fiber: Fiber, priorityLevel: PriorityLevel) => void,\n  getPriorityContext: () => PriorityLevel,\n  memoizeProps: (workInProgress: Fiber, props: any) => void,\n  memoizeState: (workInProgress: Fiber, state: any) => void,\n) {\n  // Class component state updater\n  const updater = {\n    isMounted,\n    enqueueSetState(instance, partialState, callback) {\n      const fiber = ReactInstanceMap.get(instance);\n      const priorityLevel = getPriorityContext();\n      callback = callback === undefined ? null : callback;\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      addUpdate(fiber, partialState, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    },\n    enqueueReplaceState(instance, state, callback) {\n      const fiber = ReactInstanceMap.get(instance);\n      const priorityLevel = getPriorityContext();\n      callback = callback === undefined ? null : callback;\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      addReplaceUpdate(fiber, state, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    },\n    enqueueForceUpdate(instance, callback) {\n      const fiber = ReactInstanceMap.get(instance);\n      const priorityLevel = getPriorityContext();\n      callback = callback === undefined ? null : callback;\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      addForceUpdate(fiber, callback, priorityLevel);\n      scheduleUpdate(fiber, priorityLevel);\n    },\n  };\n\n  function checkShouldComponentUpdate(\n    workInProgress,\n    oldProps,\n    newProps,\n    oldState,\n    newState,\n    newContext,\n  ) {\n    if (\n      oldProps === null ||\n      (workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate)\n    ) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    const instance = workInProgress.stateNode;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      if (__DEV__) {\n        startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      }\n      const shouldUpdate = instance.shouldComponentUpdate(\n        newProps,\n        newState,\n        newContext,\n      );\n      if (__DEV__) {\n        stopPhaseTimer();\n      }\n\n      if (__DEV__) {\n        warning(\n          shouldUpdate !== undefined,\n          '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n            'boolean value. Make sure to return true or false.',\n          getComponentName(workInProgress) || 'Unknown',\n        );\n      }\n\n      return shouldUpdate;\n    }\n\n    const type = workInProgress.type;\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) ||\n        !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress: Fiber) {\n    const instance = workInProgress.stateNode;\n    if (__DEV__) {\n      const name = getComponentName(workInProgress);\n      const renderPresent = instance.render;\n      warning(\n        renderPresent,\n        '%s(...): No `render` method found on the returned component ' +\n          'instance: you may have forgotten to define `render`.',\n        name,\n      );\n      const noGetInitialStateOnES6 = !instance.getInitialState ||\n        instance.getInitialState.isReactClassApproved ||\n        instance.state;\n      warning(\n        noGetInitialStateOnES6,\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Did you mean to define a state property instead?',\n        name,\n      );\n      const noGetDefaultPropsOnES6 = !instance.getDefaultProps ||\n        instance.getDefaultProps.isReactClassApproved;\n      warning(\n        noGetDefaultPropsOnES6,\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Use a static property to define defaultProps instead.',\n        name,\n      );\n      const noInstancePropTypes = !instance.propTypes;\n      warning(\n        noInstancePropTypes,\n        'propTypes was defined as an instance property on %s. Use a static ' +\n          'property to define propTypes instead.',\n        name,\n      );\n      const noInstanceContextTypes = !instance.contextTypes;\n      warning(\n        noInstanceContextTypes,\n        'contextTypes was defined as an instance property on %s. Use a static ' +\n          'property to define contextTypes instead.',\n        name,\n      );\n      const noComponentShouldUpdate = typeof instance.componentShouldUpdate !==\n        'function';\n      warning(\n        noComponentShouldUpdate,\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        name,\n      );\n      const noComponentDidUnmount = typeof instance.componentDidUnmount !==\n        'function';\n      warning(\n        noComponentDidUnmount,\n        '%s has a method called ' +\n          'componentDidUnmount(). But there is no such lifecycle method. ' +\n          'Did you mean componentWillUnmount()?',\n        name,\n      );\n      const noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !==\n        'function';\n      warning(\n        noComponentWillRecieveProps,\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        name,\n      );\n      const hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(\n        instance.props === undefined || !hasMutatedProps,\n        '%s(...): When calling super() in `%s`, make sure to pass ' +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name,\n      );\n    }\n\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      invariant(\n        false,\n        '%s.state: must be set to an object or null',\n        getComponentName(workInProgress),\n      );\n    }\n    if (typeof instance.getChildContext === 'function') {\n      invariant(\n        typeof workInProgress.type.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        getComponentName(workInProgress),\n      );\n    }\n  }\n\n  function resetInputPointers(workInProgress: Fiber, instance: any) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress: Fiber, instance: any): void {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    ReactInstanceMap.set(instance, workInProgress);\n  }\n\n  function constructClassInstance(workInProgress: Fiber): any {\n    const ctor = workInProgress.type;\n    const props = workInProgress.pendingProps;\n    const unmaskedContext = getUnmaskedContext(workInProgress);\n    const needsContext = isContextConsumer(workInProgress);\n    const context = needsContext\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyObject;\n    const instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n    checkClassInstance(workInProgress);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ): void {\n    const instance = workInProgress.stateNode;\n    const state = instance.state || null;\n\n    let props = workInProgress.pendingProps;\n    invariant(\n      props,\n      'There must be pending props for an initial mount. This error is ' +\n        'likely caused by a bug in React. Please file an issue.',\n    );\n\n    const unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (typeof instance.componentWillMount === 'function') {\n      if (__DEV__) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n      }\n      instance.componentWillMount();\n      if (__DEV__) {\n        stopPhaseTimer();\n      }\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      const updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = beginUpdateQueue(\n          workInProgress,\n          updateQueue,\n          instance,\n          state,\n          props,\n          priorityLevel,\n        );\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  function resumeMountClassInstance(\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ): boolean {\n    const instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    let newState = workInProgress.memoizedState;\n    let newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there isn't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = workInProgress.memoizedProps;\n      invariant(\n        newProps != null,\n        'There should always be pending or memoized props. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n    const newUnmaskedContext = getUnmaskedContext(workInProgress);\n    const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // TODO: Should we deal with a setState that happened after the last\n    // componentWillMount and before this componentWillMount? Probably\n    // unsupported anyway.\n\n    if (\n      !checkShouldComponentUpdate(\n        workInProgress,\n        workInProgress.memoizedProps,\n        newProps,\n        workInProgress.memoizedState,\n        newState,\n        newContext,\n      )\n    ) {\n      // Update the existing instance's state, props, and context pointers even\n      // though we're bailing out.\n      instance.props = newProps;\n      instance.state = newState;\n      instance.context = newContext;\n      return false;\n    }\n\n    // If we didn't bail out we need to construct a new instance. We don't\n    // want to reuse one that failed to fully mount.\n    const newInstance = constructClassInstance(workInProgress);\n    newInstance.props = newProps;\n    newInstance.state = (newState = newInstance.state || null);\n    newInstance.context = newContext;\n\n    if (typeof newInstance.componentWillMount === 'function') {\n      if (__DEV__) {\n        startPhaseTimer(workInProgress, 'componentWillMount');\n      }\n      newInstance.componentWillMount();\n      if (__DEV__) {\n        stopPhaseTimer();\n      }\n    }\n    // If we had additional state updates, process them now.\n    // They may be from componentWillMount() or from error boundary's setState()\n    // during initial mounting.\n    const newUpdateQueue = workInProgress.updateQueue;\n    if (newUpdateQueue !== null) {\n      newInstance.state = beginUpdateQueue(\n        workInProgress,\n        newUpdateQueue,\n        newInstance,\n        newState,\n        newProps,\n        priorityLevel,\n      );\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return true;\n  }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(\n    current: Fiber,\n    workInProgress: Fiber,\n    priorityLevel: PriorityLevel,\n  ): boolean {\n    const instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    const oldProps = workInProgress.memoizedProps;\n    let newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      invariant(\n        newProps != null,\n        'There should always be pending or memoized props. This error is ' +\n          'likely caused by a bug in React. Please file an issue.',\n      );\n    }\n    const oldContext = instance.context;\n    const newUnmaskedContext = getUnmaskedContext(workInProgress);\n    const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (oldProps !== newProps || oldContext !== newContext) {\n      if (typeof instance.componentWillReceiveProps === 'function') {\n        if (__DEV__) {\n          startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n        }\n        instance.componentWillReceiveProps(newProps, newContext);\n        if (__DEV__) {\n          stopPhaseTimer();\n        }\n\n        if (instance.state !== workInProgress.memoizedState) {\n          if (__DEV__) {\n            warning(\n              false,\n              '%s.componentWillReceiveProps(): Assigning directly to ' +\n                \"this.state is deprecated (except inside a component's \" +\n                'constructor). Use setState instead.',\n              getComponentName(workInProgress),\n            );\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    const updateQueue = workInProgress.updateQueue;\n    const oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    let newState;\n    if (updateQueue !== null) {\n      newState = beginUpdateQueue(\n        workInProgress,\n        updateQueue,\n        instance,\n        oldState,\n        newProps,\n        priorityLevel,\n      );\n    } else {\n      newState = oldState;\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(updateQueue !== null && updateQueue.hasForceUpdate)\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    const shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext,\n    );\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        if (__DEV__) {\n          startPhaseTimer(workInProgress, 'componentWillUpdate');\n        }\n        instance.componentWillUpdate(newProps, newState, newContext);\n        if (__DEV__) {\n          stopPhaseTimer();\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance,\n    constructClassInstance,\n    mountClassInstance,\n    resumeMountClassInstance,\n    updateClassInstance,\n  };\n};\n"]}]