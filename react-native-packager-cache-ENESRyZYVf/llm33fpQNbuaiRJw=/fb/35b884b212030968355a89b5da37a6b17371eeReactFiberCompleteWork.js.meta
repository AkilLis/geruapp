["47b0a776293c52caa8efdbd7d9f27a19321f61b3","2f85e40aa76657804da025dccbd882901f09c4cf",["ReactChildFiber","ReactFiberContext","ReactTypeOfWork","ReactTypeOfSideEffect","ReactDebugCurrentFiber","fbjs/lib/invariant"],[40,143,251,307,1054,1108],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberCompleteWork.js"],"names":["require","reconcileChildFibers","popContextProvider","ReactTypeOfWork","ReactTypeOfSideEffect","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","CoroutineComponent","CoroutineHandlerPhase","YieldComponent","Fragment","Ref","Update","__DEV__","ReactDebugCurrentFiber","invariant","module","exports","config","hostContext","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","getRootHostContainer","popHostContext","getHostContext","popHostContainer","markChildAsProgressed","current","workInProgress","priorityLevel","progressedChild","child","progressedPriority","markUpdate","effectTag","markRef","appendAllYields","yields","node","stateNode","return","tag","push","type","sibling","moveCoroutineToHandlerPhase","coroutine","memoizedProps","fn","handler","props","nextChildren","currentFirstChild","priority","pendingWorkPriority","appendAllChildren","parent","completeWork","fiberRoot","pendingContext","context","rootContainerInstance","newProps","oldProps","instance","currentHostContext","updatePayload","updateQueue","ref","newText","oldText","textInstance"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberCompleteWork\n * @flow\n */\n\n'use strict';\n\nimport type {ReactCoroutine} from 'ReactCoroutine';\nimport type {Fiber} from 'ReactFiber';\nimport type {HostContext} from 'ReactFiberHostContext';\nimport type {FiberRoot} from 'ReactFiberRoot';\nimport type {HostConfig} from 'ReactFiberReconciler';\n\nvar {reconcileChildFibers} = require('ReactChildFiber');\nvar {\n  popContextProvider,\n} = require('ReactFiberContext');\nvar ReactTypeOfWork = require('ReactTypeOfWork');\nvar ReactTypeOfSideEffect = require('ReactTypeOfSideEffect');\nvar {\n  IndeterminateComponent,\n  FunctionalComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  CoroutineComponent,\n  CoroutineHandlerPhase,\n  YieldComponent,\n  Fragment,\n} = ReactTypeOfWork;\nvar {\n  Ref,\n  Update,\n} = ReactTypeOfSideEffect;\n\nif (__DEV__) {\n  var ReactDebugCurrentFiber = require('ReactDebugCurrentFiber');\n}\n\nvar invariant = require('fbjs/lib/invariant');\n\nmodule.exports = function<T, P, I, TI, PI, C, CX, PL>(\n  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,\n  hostContext: HostContext<C, CX>,\n) {\n  const {\n    createInstance,\n    createTextInstance,\n    appendInitialChild,\n    finalizeInitialChildren,\n    prepareUpdate,\n  } = config;\n\n  const {\n    getRootHostContainer,\n    popHostContext,\n    getHostContext,\n    popHostContainer,\n  } = hostContext;\n\n  function markChildAsProgressed(current, workInProgress, priorityLevel) {\n    // We now have clones. Let's store them as the currently progressed work.\n    workInProgress.progressedChild = workInProgress.child;\n    workInProgress.progressedPriority = priorityLevel;\n    if (current !== null) {\n      // We also store it on the current. When the alternate swaps in we can\n      // continue from this point.\n      current.progressedChild = workInProgress.progressedChild;\n      current.progressedPriority = workInProgress.progressedPriority;\n    }\n  }\n\n  function markUpdate(workInProgress: Fiber) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress: Fiber) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllYields(yields: Array<mixed>, workInProgress: Fiber) {\n    let node = workInProgress.stateNode;\n    if (node) {\n      node.return = workInProgress;\n    }\n    while (node !== null) {\n      if (\n        node.tag === HostComponent ||\n        node.tag === HostText ||\n        node.tag === HostPortal\n      ) {\n        invariant(false, 'A coroutine cannot have host component children.');\n      } else if (node.tag === YieldComponent) {\n        yields.push(node.type);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  function moveCoroutineToHandlerPhase(\n    current: Fiber | null,\n    workInProgress: Fiber,\n  ) {\n    var coroutine = (workInProgress.memoizedProps: ?ReactCoroutine);\n    invariant(\n      coroutine,\n      'Should be resolved by now. This error is likely caused by a bug in ' +\n        'React. Please file an issue.',\n    );\n\n    // First step of the coroutine has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage coroutine represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CoroutineHandlerPhase;\n\n    // Build up the yields.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var yields: Array<mixed> = [];\n    appendAllYields(yields, workInProgress);\n    var fn = coroutine.handler;\n    var props = coroutine.props;\n    var nextChildren = fn(props, yields);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    // Inherit the priority of the returnFiber.\n    const priority = workInProgress.pendingWorkPriority;\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      currentFirstChild,\n      nextChildren,\n      priority,\n    );\n    markChildAsProgressed(current, workInProgress, priority);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent: I, workInProgress: Fiber) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node = node.sibling;\n    }\n  }\n\n  function completeWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n  ): Fiber | null {\n    if (__DEV__) {\n      ReactDebugCurrentFiber.current = workInProgress;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent: {\n        // We are leaving this subtree, so pop context if any.\n        popContextProvider(workInProgress);\n        return null;\n      }\n      case HostRoot: {\n        // TODO: Pop the host container after #8607 lands.\n        const fiberRoot = (workInProgress.stateNode: FiberRoot);\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type;\n        const newProps = workInProgress.memoizedProps;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          const oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          const instance: I = workInProgress.stateNode;\n          const currentHostContext = getHostContext();\n          const updatePayload = prepareUpdate(\n            instance,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n          );\n\n          // TODO: Type this specific to this type of component.\n          workInProgress.updateQueue = (updatePayload: any);\n          // If the update payload indicates that there is a change or if there\n          // is a new ref we mark this as an update.\n          if (updatePayload) {\n            markUpdate(workInProgress);\n          }\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(\n              workInProgress.stateNode !== null,\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n\n          const currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          const instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n\n          appendAllChildren(instance, workInProgress);\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n\n          workInProgress.stateNode = instance;\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        return null;\n      }\n      case HostText: {\n        let newText = workInProgress.memoizedProps;\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          if (oldText !== newText) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          if (typeof newText !== 'string') {\n            invariant(\n              workInProgress.stateNode !== null,\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          const textInstance = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n          workInProgress.stateNode = textInstance;\n        }\n        return null;\n      }\n      case CoroutineComponent:\n        return moveCoroutineToHandlerPhase(current, workInProgress);\n      case CoroutineHandlerPhase:\n        // Reset the tag to now be a first phase coroutine.\n        workInProgress.tag = CoroutineComponent;\n        return null;\n      case YieldComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        // TODO: Only mark this as an update if we have any pending callbacks.\n        markUpdate(workInProgress);\n        popHostContainer(workInProgress);\n        return null;\n\n      // Error cases\n      case IndeterminateComponent:\n        invariant(\n          false,\n          'An indeterminate component should have become determinate before ' +\n            'completing. This error is likely caused by a bug in React. Please ' +\n            'file an issue.',\n        );\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(\n          false,\n          'Unknown unit of work tag. This error is likely caused by a bug in ' +\n            'React. Please file an issue.',\n        );\n    }\n  }\n\n  return {\n    completeWork,\n  };\n};\n"]}]