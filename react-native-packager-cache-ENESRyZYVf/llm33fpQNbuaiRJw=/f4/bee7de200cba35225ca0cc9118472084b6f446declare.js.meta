["0c7bb65d4dbce41ecd47c149a68f48ab369f723e","7327000851bf26bce57200fb29591da92fc0b512",["./assert","./isTypeName","./isType","./isNil","./mixin","./getTypeName","./isUnion"],[21,59,97,130,162,200,240],{"version":3,"sources":["/var/www/geruapp/node_modules/tcomb/lib/declare.js"],"names":["assert","require","isTypeName","isType","isNil","mixin","getTypeName","isUnion","nextDeclareUniqueId","module","exports","declare","name","process","env","NODE_ENV","type","Declare","value","path","dispatch","define","spec","stringify","meta","Object","keys","prototype","length","hasOwnProperty","displayName","identity"],"mappings":"AAAA,IAAIA,SAASC,QAAQ,UAAR,CAAb;AACA,IAAIC,aAAaD,QAAQ,cAAR,CAAjB;AACA,IAAIE,SAASF,QAAQ,UAAR,CAAb;AACA,IAAIG,QAAQH,QAAQ,SAAR,CAAZ;AACA,IAAII,QAAQJ,QAAQ,SAAR,CAAZ;AACA,IAAIK,cAAcL,QAAQ,eAAR,CAAlB;AACA,IAAIM,UAAUN,QAAQ,WAAR,CAAd;;AAIA,IAAIO,sBAAsB,CAA1B;;AAEAC,OAAOC,OAAP,GAAiB,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACtC,MAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCf,WAAOE,WAAWU,IAAX,CAAP,EAAyB,YAAY;AAAE,aAAO,2BAA2BA,IAA3B,GAAkC,kDAAzC;AAA8F,KAArI;AACD;;AAED,MAAII,IAAJ;;AAEA,WAASC,OAAT,CAAiBC,KAAjB,EAAwBC,IAAxB,EAA8B;AAC5B,QAAIN,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCf,aAAO,CAACI,MAAMY,IAAN,CAAR,EAAqB,YAAY;AAAE,eAAO,qFAAP;AAA+F,OAAlI;AACA,UAAIT,QAAQS,IAAR,CAAJ,EAAmB;AACjBhB,eAAOgB,KAAKI,QAAL,KAAkBH,QAAQG,QAAjC,EAA2C,YAAY;AAAE,iBAAO,8BAA8BR,IAA9B,GAAqC,oCAArC,GAA4EA,IAA5E,GAAmF,WAA1F;AAAwG,SAAjK;AACD;AACF;AACD,WAAOI,KAAKE,KAAL,EAAYC,IAAZ,CAAP;AACD;;AAEDF,UAAQI,MAAR,GAAiB,UAAUC,IAAV,EAAgB;AAC/B,QAAIT,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCf,aAAOG,OAAOmB,IAAP,CAAP,EAAqB,YAAY;AAAE,eAAO,2BAA2BtB,OAAOuB,SAAP,CAAiBD,IAAjB,CAA3B,GAAqD,6CAA5D;AAA4G,OAA/I;AACAtB,aAAOI,MAAMY,IAAN,CAAP,EAAoB,YAAY;AAAE,eAAO,+CAAP;AAAyD,OAA3F;AACAhB,aAAOI,MAAMkB,KAAKE,IAAL,CAAUZ,IAAhB,KAAyBa,OAAOC,IAAP,CAAYJ,KAAKK,SAAjB,EAA4BC,MAA5B,KAAuC,CAAvE,EAA0E,YAAY;AAAE,eAAO,2BAA2B5B,OAAOuB,SAAP,CAAiBD,IAAjB,CAA3B,GAAoD,4DAA3D;AAA0H,OAAlN;AACD;;AAED,QAAIf,QAAQe,IAAR,KAAiBL,QAAQY,cAAR,CAAuB,UAAvB,CAArB,EAAyD;AACvDP,WAAKF,QAAL,GAAgBH,QAAQG,QAAxB;AACD;AACDJ,WAAOM,IAAP;AACAjB,UAAMY,OAAN,EAAeD,IAAf,EAAqB,IAArB;AACA,QAAIJ,IAAJ,EAAU;AACRI,WAAKc,WAAL,GAAmBb,QAAQa,WAAR,GAAsBlB,IAAzC;AACAK,cAAQO,IAAR,CAAaZ,IAAb,GAAoBA,IAApB;AACD;AACDK,YAAQO,IAAR,CAAaO,QAAb,GAAwBf,KAAKQ,IAAL,CAAUO,QAAlC;AACAd,YAAQU,SAAR,GAAoBX,KAAKW,SAAzB;AACA,WAAOV,OAAP;AACD,GAnBD;;AAqBAA,UAAQa,WAAR,GAAsBlB,QAAUN,YAAYW,OAAZ,IAAuB,GAAvB,GAA6BT,qBAA7D;;AAEAS,UAAQO,IAAR,GAAe,EAAEO,UAAU,KAAZ,EAAf;AACAd,UAAQU,SAAR,GAAoB,IAApB;AACA,SAAOV,OAAP;AACD,CA3CD","sourcesContent":["var assert = require('./assert');\nvar isTypeName = require('./isTypeName');\nvar isType = require('./isType');\nvar isNil = require('./isNil');\nvar mixin = require('./mixin');\nvar getTypeName = require('./getTypeName');\nvar isUnion = require('./isUnion');\n\n// All the .declare-d types should be clearly different from each other thus they should have\n// different names when a name was not explicitly provided.\nvar nextDeclareUniqueId = 1;\n\nmodule.exports = function declare(name) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });\n  }\n\n  var type;\n\n  function Declare(value, path) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!isNil(type), function () { return 'Type declared but not defined, don\\'t forget to call .define on every declared type'; });\n      if (isUnion(type)) {\n        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()'; });\n      }\n    }\n    return type(value, path);\n  }\n\n  Declare.define = function (spec) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });\n      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });\n      assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });\n    }\n\n    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {\n      spec.dispatch = Declare.dispatch;\n    }\n    type = spec;\n    mixin(Declare, type, true); // true because it overwrites Declare.displayName\n    if (name) {\n      type.displayName = Declare.displayName = name;\n      Declare.meta.name = name;\n    }\n    Declare.meta.identity = type.meta.identity;\n    Declare.prototype = type.prototype;\n    return Declare;\n  };\n\n  Declare.displayName = name || ( getTypeName(Declare) + \"$\" + nextDeclareUniqueId++ );\n  // in general I can't say if this type will be an identity, for safety setting to false\n  Declare.meta = { identity: false };\n  Declare.prototype = null;\n  return Declare;\n};\n"]}]