["a8c7fb3a8fa1009de1f8d9f2e27452ff00e04b45","fb136dc50d3493c820ccc07df3c512811b29d7b0",["ReactNativePropRegistry","deepDiffer","flattenStyle"],[54,108,150],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/native/ReactNativeAttributePayload.js"],"names":["ReactNativePropRegistry","require","deepDiffer","flattenStyle","emptyObject","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","resolveObject","idOrObject","getByID","restoreDeletedValuesInNestedArray","updatePayload","node","validAttributes","Array","isArray","i","length","obj","propKey","undefined","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","props","ReactNativeAttributePayload","create","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNativeAttributePayload\n * @flow\n */\n'use strict';\n\nvar ReactNativePropRegistry = require('ReactNativePropRegistry');\n\nvar deepDiffer = require('deepDiffer');\nvar flattenStyle = require('flattenStyle');\n\nvar emptyObject = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\ntype AttributeDiffer = (prevProp: mixed, nextProp: mixed) => boolean;\ntype AttributePreprocessor = (nextProp: mixed) => mixed;\n\ntype CustomAttributeConfiguration =\n  | {diff: AttributeDiffer, process: AttributePreprocessor}\n  | {diff: AttributeDiffer}\n  | {process: AttributePreprocessor};\n\ntype AttributeConfiguration = {\n  [key: string]:\n    | CustomAttributeConfiguration\n    | AttributeConfiguration /*| boolean*/,\n};\n\ntype NestedNode = Array<NestedNode> | Object | number;\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp: mixed, nextProp: mixed): boolean {\n  if (typeof nextProp !== 'object' || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction resolveObject(idOrObject: number | Object): Object {\n  if (typeof idOrObject === 'number') {\n    return ReactNativePropRegistry.getByID(idOrObject);\n  }\n  return idOrObject;\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload: Object,\n  node: NestedNode,\n  validAttributes: AttributeConfiguration,\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes,\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = resolveObject(node);\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof nextProp === 'function') {\n        nextProp = true;\n      }\n      if (typeof nextProp === 'undefined') {\n        nextProp = null;\n      }\n\n      if (typeof attributeConfig !== 'object') {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === 'function' ||\n        typeof attributeConfig.process === 'function'\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue = typeof attributeConfig.process === 'function'\n          ? attributeConfig.process(nextProp)\n          : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload: ?Object,\n  prevArray: Array<NestedNode>,\n  nextArray: Array<NestedNode>,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  var minLength = prevArray.length < nextArray.length\n    ? prevArray.length\n    : nextArray.length;\n  var i;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes,\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes,\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes,\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload: ?Object,\n  prevProp: NestedNode,\n  nextProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      resolveObject(nextProp),\n      validAttributes,\n    );\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes,\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      resolveObject(nextProp),\n      validAttributes,\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    resolveObject(prevProp),\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes,\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(\n  updatePayload: ?Object,\n  nextProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(\n      updatePayload,\n      resolveObject(nextProp),\n      validAttributes,\n    );\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes,\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(\n  updatePayload: ?Object,\n  prevProp: NestedNode,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      validAttributes,\n    );\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes,\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(\n  updatePayload: ?Object,\n  prevProps: Object,\n  nextProps: Object,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  var attributeConfig: ?(CustomAttributeConfiguration | AttributeConfiguration);\n  var nextProp;\n  var prevProp;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === 'function') {\n      nextProp = (true: any);\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === 'function') {\n        prevProp = (true: any);\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === 'undefined') {\n      nextProp = (null: any);\n      if (typeof prevProp === 'undefined') {\n        prevProp = (null: any);\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== 'object') {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === 'function' ||\n        typeof attributeConfig.process === 'function'\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue = typeof attributeConfig.process === 'function'\n          ? attributeConfig.process(nextProp)\n          : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== 'object') {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === 'function' ||\n      typeof attributeConfig.process === 'function'\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate = prevProp === undefined ||\n        (typeof attributeConfig.diff === 'function'\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        nextValue = typeof attributeConfig.process === 'function'\n          ? attributeConfig.process(nextProp)\n          : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        ((attributeConfig: any): AttributeConfiguration),\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          ((attributeConfig: any): AttributeConfiguration),\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (propKey in prevProps) {\n    if (nextProps[propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== 'object' ||\n      typeof attributeConfig.diff === 'function' ||\n      typeof attributeConfig.process === 'function'\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[propKey]) {\n        removedKeys[propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        ((attributeConfig: any): AttributeConfiguration),\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(\n  updatePayload: ?Object,\n  props: Object,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(\n  updatePayload: ?Object,\n  prevProps: Object,\n  validAttributes: AttributeConfiguration,\n): ?Object {\n  // TODO: Fast path\n  return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n}\n\nvar ReactNativeAttributePayload = {\n  create: function(\n    props: Object,\n    validAttributes: AttributeConfiguration,\n  ): ?Object {\n    return addProperties(\n      null, // updatePayload\n      props,\n      validAttributes,\n    );\n  },\n\n  diff: function(\n    prevProps: Object,\n    nextProps: Object,\n    validAttributes: AttributeConfiguration,\n  ): ?Object {\n    return diffProperties(\n      null, // updatePayload\n      prevProps,\n      nextProps,\n      validAttributes,\n    );\n  },\n};\n\nmodule.exports = ReactNativeAttributePayload;\n"]}]