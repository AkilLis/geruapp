["751ce6d7404b7598eab7c74b4e711f32d0f50e19","53524031a077dae815707ce3704c094c14fdf751",["ReactTypeOfWork","ReactFiberUpdateQueue","ReactFiberDevToolsHook","ReactErrorUtils","ReactTypeOfSideEffect","fbjs/lib/invariant","ReactDebugFiberPerf"],[47,383,482,583,689,886,951],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberCommitWork.js"],"names":["ReactTypeOfWork","require","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","CoroutineComponent","commitCallbacks","onCommitUnmount","invokeGuardedCallback","Placement","Update","Callback","ContentReset","invariant","__DEV__","startPhaseTimer","stopPhaseTimer","module","exports","config","captureError","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","insertBefore","removeChild","getPublicInstance","callComponentWillUnmountWithTimerInDev","current","instance","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","ref","refError","getHostParent","fiber","parent","return","tag","stateNode","containerInfo","getHostParentFiber","isHostParent","getHostSibling","node","siblings","sibling","effectTag","child","commitPlacement","finishedWork","parentFiber","before","commitNestedUnmounts","root","commitUnmount","unmountHostComponents","commitDeletion","alternate","commitWork","newProps","memoizedProps","oldProps","type","updatePayload","updateQueue","textInstance","newText","oldText","commitLifeCycles","componentDidMount","prevProps","prevState","memoizedState","componentDidUpdate","props","commitAttachRef","commitDetachRef","currentRef"],"mappings":";;AAYA;;AAKA,IAAIA,kBAAkBC,QAAQ,iBAAR,CAAtB;IAEEC,c,GAMEF,e,CANFE,c;IACAC,Q,GAKEH,e,CALFG,Q;IACAC,a,GAIEJ,e,CAJFI,a;IACAC,Q,GAGEL,e,CAHFK,Q;IACAC,U,GAEEN,e,CAFFM,U;IACAC,kB,GACEP,e,CADFO,kB;;eAEsBN,QAAQ,uBAAR,C;IAAnBO,e,YAAAA,e;;gBACmBP,QAAQ,wBAAR,C;IAAnBQ,e,aAAAA,e;;gBACyBR,QAAQ,iBAAR,C;IAAzBS,qB,aAAAA,qB;;gBAODT,QAAQ,uBAAR,C;IAJFU,S,aAAAA,S;IACAC,M,aAAAA,M;IACAC,Q,aAAAA,Q;IACAC,Y,aAAAA,Y;;AAGF,IAAIC,YAAYd,QAAQ,oBAAR,CAAhB;;AAEA,IAAIe,OAAJ,EAAa;AAAA,kBAIPf,QAAQ,qBAAR,CAJO;AAAA,MAETgB,eAFS,aAETA,eAFS;AAAA,MAGTC,cAHS,aAGTA,cAHS;AAKZ;;AAEDC,OAAOC,OAAP,GAAiB,UACfC,MADe,EAEfC,YAFe,EAGf;AAAA,MAEEC,WAFF,GAUIF,MAVJ,CAEEE,WAFF;AAAA,MAGEC,YAHF,GAUIH,MAVJ,CAGEG,YAHF;AAAA,MAIEC,gBAJF,GAUIJ,MAVJ,CAIEI,gBAJF;AAAA,MAKEC,gBALF,GAUIL,MAVJ,CAKEK,gBALF;AAAA,MAMEC,WANF,GAUIN,MAVJ,CAMEM,WANF;AAAA,MAOEC,YAPF,GAUIP,MAVJ,CAOEO,YAPF;AAAA,MAQEC,WARF,GAUIR,MAVJ,CAQEQ,WARF;AAAA,MASEC,iBATF,GAUIT,MAVJ,CASES,iBATF;;;AAYA,MAAId,OAAJ,EAAa;AACX,QAAIe,yCAAyC,SAAzCA,sCAAyC,CAASC,OAAT,EAAkBC,QAAlB,EAA4B;AACvEhB,sBAAgBe,OAAhB,EAAyB,sBAAzB;AACAC,eAASC,oBAAT;AACAhB;AACD,KAJD;AAKD;;AAGD,WAASiB,8BAAT,CAAwCH,OAAxC,EAAiDC,QAAjD,EAA2D;AACzD,QAAIjB,OAAJ,EAAa;AACX,UAAMoB,eAAe1B,sBACnB,IADmB,EAEnBqB,sCAFmB,EAGnB,IAHmB,EAInBC,OAJmB,EAKnBC,QALmB,CAArB;AAOA,UAAIG,YAAJ,EAAkB;AAChBd,qBAAaU,OAAb,EAAsBI,YAAtB;AACD;AACF,KAXD,MAWO;AACL,UAAI;AACFH,iBAASC,oBAAT;AACD,OAFD,CAEE,OAAOE,YAAP,EAAqB;AACrBd,qBAAaU,OAAb,EAAsBI,YAAtB;AACD;AACF;AACF;;AAED,WAASC,eAAT,CAAyBL,OAAzB,EAAyC;AACvC,QAAMM,MAAMN,QAAQM,GAApB;AACA,QAAIA,QAAQ,IAAZ,EAAkB;AAChB,UAAItB,OAAJ,EAAa;AACX,YAAMuB,WAAW7B,sBAAsB,IAAtB,EAA4B4B,GAA5B,EAAiC,IAAjC,EAAuC,IAAvC,CAAjB;AACA,YAAIC,aAAa,IAAjB,EAAuB;AACrBjB,uBAAaU,OAAb,EAAsBO,QAAtB;AACD;AACF,OALD,MAKO;AACL,YAAI;AACFD,cAAI,IAAJ;AACD,SAFD,CAEE,OAAOC,QAAP,EAAiB;AACjBjB,uBAAaU,OAAb,EAAsBO,QAAtB;AACD;AACF;AACF;AACF;;AAED,WAASC,aAAT,CAAuBC,KAAvB,EAA4C;AAC1C,QAAIC,SAASD,MAAME,MAAnB;AACA,WAAOD,WAAW,IAAlB,EAAwB;AACtB,cAAQA,OAAOE,GAAf;AACE,aAAKxC,aAAL;AACE,iBAAOsC,OAAOG,SAAd;AACF,aAAK1C,QAAL;AACE,iBAAOuC,OAAOG,SAAP,CAAiBC,aAAxB;AACF,aAAKxC,UAAL;AACE,iBAAOoC,OAAOG,SAAP,CAAiBC,aAAxB;AANJ;AAQAJ,eAASA,OAAOC,MAAhB;AACD;AACD5B,cACE,KADF,EAEE,0EACE,iCAHJ;AAKD;;AAED,WAASgC,kBAAT,CAA4BN,KAA5B,EAAiD;AAC/C,QAAIC,SAASD,MAAME,MAAnB;AACA,WAAOD,WAAW,IAAlB,EAAwB;AACtB,UAAIM,aAAaN,MAAb,CAAJ,EAA0B;AACxB,eAAOA,MAAP;AACD;AACDA,eAASA,OAAOC,MAAhB;AACD;AACD5B,cACE,KADF,EAEE,0EACE,iCAHJ;AAKD;;AAED,WAASiC,YAAT,CAAsBP,KAAtB,EAA6C;AAC3C,WAAOA,MAAMG,GAAN,KAAcxC,aAAd,IACLqC,MAAMG,GAAN,KAAczC,QADT,IAELsC,MAAMG,GAAN,KAActC,UAFhB;AAGD;;AAED,WAAS2C,cAAT,CAAwBR,KAAxB,EAA0C;AAKxC,QAAIS,OAAcT,KAAlB;AACAU,cAAU,OAAO,IAAP,EAAa;AAErB,aAAOD,KAAKE,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,YAAIF,KAAKP,MAAL,KAAgB,IAAhB,IAAwBK,aAAaE,KAAKP,MAAlB,CAA5B,EAAuD;AAGrD,iBAAO,IAAP;AACD;AACDO,eAAOA,KAAKP,MAAZ;AACD;AACDO,WAAKE,OAAL,CAAaT,MAAb,GAAsBO,KAAKP,MAA3B;AACAO,aAAOA,KAAKE,OAAZ;AACA,aAAOF,KAAKN,GAAL,KAAaxC,aAAb,IAA8B8C,KAAKN,GAAL,KAAavC,QAAlD,EAA4D;AAG1D,YAAI6C,KAAKG,SAAL,GAAiB1C,SAArB,EAAgC;AAE9B,mBAASwC,QAAT;AACD;;AAGD,YAAID,KAAKI,KAAL,KAAe,IAAf,IAAuBJ,KAAKN,GAAL,KAAatC,UAAxC,EAAoD;AAClD,mBAAS6C,QAAT;AACD,SAFD,MAEO;AACLD,eAAKI,KAAL,CAAWX,MAAX,GAAoBO,IAApB;AACAA,iBAAOA,KAAKI,KAAZ;AACD;AACF;;AAED,UAAI,EAAEJ,KAAKG,SAAL,GAAiB1C,SAAnB,CAAJ,EAAmC;AAEjC,eAAOuC,KAAKL,SAAZ;AACD;AACF;AACF;;AAED,WAASU,eAAT,CAAyBC,YAAzB,EAAoD;AAElD,QAAMC,cAAcV,mBAAmBS,YAAnB,CAApB;AACA,QAAId,eAAJ;AACA,YAAQe,YAAYb,GAApB;AACE,WAAKxC,aAAL;AACEsC,iBAASe,YAAYZ,SAArB;AACA;AACF,WAAK1C,QAAL;AACEuC,iBAASe,YAAYZ,SAAZ,CAAsBC,aAA/B;AACA;AACF,WAAKxC,UAAL;AACEoC,iBAASe,YAAYZ,SAAZ,CAAsBC,aAA/B;AACA;AACF;AACE/B,kBACE,KADF,EAEE,qEACE,iCAHJ;AAXJ;AAiBA,QAAI0C,YAAYJ,SAAZ,GAAwBvC,YAA5B,EAA0C;AAExCW,uBAAiBiB,MAAjB;;AAEAe,kBAAYJ,SAAZ,IAAyB,CAACvC,YAA1B;AACD;;AAED,QAAM4C,SAAST,eAAeO,YAAf,CAAf;;AAGA,QAAIN,OAAcM,YAAlB;AACA,WAAO,IAAP,EAAa;AACX,UAAIN,KAAKN,GAAL,KAAaxC,aAAb,IAA8B8C,KAAKN,GAAL,KAAavC,QAA/C,EAAyD;AACvD,YAAIqD,MAAJ,EAAY;AACV9B,uBAAac,MAAb,EAAqBQ,KAAKL,SAA1B,EAAqCa,MAArC;AACD,SAFD,MAEO;AACL/B,sBAAYe,MAAZ,EAAoBQ,KAAKL,SAAzB;AACD;AACF,OAND,MAMO,IAAIK,KAAKN,GAAL,KAAatC,UAAjB,EAA6B,CAInC,CAJM,MAIA,IAAI4C,KAAKI,KAAL,KAAe,IAAnB,EAAyB;AAC9BJ,aAAKI,KAAL,CAAWX,MAAX,GAAoBO,IAApB;AACAA,eAAOA,KAAKI,KAAZ;AACA;AACD;AACD,UAAIJ,SAASM,YAAb,EAA2B;AACzB;AACD;AACD,aAAON,KAAKE,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,YAAIF,KAAKP,MAAL,KAAgB,IAAhB,IAAwBO,KAAKP,MAAL,KAAgBa,YAA5C,EAA0D;AACxD;AACD;AACDN,eAAOA,KAAKP,MAAZ;AACD;AACDO,WAAKE,OAAL,CAAaT,MAAb,GAAsBO,KAAKP,MAA3B;AACAO,aAAOA,KAAKE,OAAZ;AACD;AACF;;AAED,WAASO,oBAAT,CAA8BC,IAA9B,EAAiD;AAM/C,QAAIV,OAAcU,IAAlB;AACA,WAAO,IAAP,EAAa;AACXC,oBAAcX,IAAd;;AAGA,UAAIA,KAAKI,KAAL,KAAe,IAAf,IAAuBJ,KAAKN,GAAL,KAAatC,UAAxC,EAAoD;AAClD4C,aAAKI,KAAL,CAAWX,MAAX,GAAoBO,IAApB;AACAA,eAAOA,KAAKI,KAAZ;AACA;AACD;AACD,UAAIJ,SAASU,IAAb,EAAmB;AACjB;AACD;AACD,aAAOV,KAAKE,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,YAAIF,KAAKP,MAAL,KAAgB,IAAhB,IAAwBO,KAAKP,MAAL,KAAgBiB,IAA5C,EAAkD;AAChD;AACD;AACDV,eAAOA,KAAKP,MAAZ;AACD;AACDO,WAAKE,OAAL,CAAaT,MAAb,GAAsBO,KAAKP,MAA3B;AACAO,aAAOA,KAAKE,OAAZ;AACD;AACF;;AAED,WAASU,qBAAT,CAA+BpB,MAA/B,EAAuCV,OAAvC,EAAsD;AAGpD,QAAIkB,OAAclB,OAAlB;AACA,WAAO,IAAP,EAAa;AACX,UAAIkB,KAAKN,GAAL,KAAaxC,aAAb,IAA8B8C,KAAKN,GAAL,KAAavC,QAA/C,EAAyD;AACvDsD,6BAAqBT,IAArB;;AAGArB,oBAAYa,MAAZ,EAAoBQ,KAAKL,SAAzB;AAED,OAND,MAMO,IAAIK,KAAKN,GAAL,KAAatC,UAAjB,EAA6B;AAGlCoC,iBAASQ,KAAKL,SAAL,CAAeC,aAAxB;;AAEA,YAAII,KAAKI,KAAL,KAAe,IAAnB,EAAyB;AACvBJ,eAAKI,KAAL,CAAWX,MAAX,GAAoBO,IAApB;AACAA,iBAAOA,KAAKI,KAAZ;AACA;AACD;AACF,OAVM,MAUA;AACLO,sBAAcX,IAAd;;AAEA,YAAIA,KAAKI,KAAL,KAAe,IAAnB,EAAyB;AACvBJ,eAAKI,KAAL,CAAWX,MAAX,GAAoBO,IAApB;AACAA,iBAAOA,KAAKI,KAAZ;AACA;AACD;AACF;AACD,UAAIJ,SAASlB,OAAb,EAAsB;AACpB;AACD;AACD,aAAOkB,KAAKE,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,YAAIF,KAAKP,MAAL,KAAgB,IAAhB,IAAwBO,KAAKP,MAAL,KAAgBX,OAA5C,EAAqD;AACnD;AACD;AACDkB,eAAOA,KAAKP,MAAZ;AACA,YAAIO,KAAKN,GAAL,KAAatC,UAAjB,EAA6B;AAG3BoC,mBAASF,cAAcU,IAAd,CAAT;AACD;AACF;AACDA,WAAKE,OAAL,CAAaT,MAAb,GAAsBO,KAAKP,MAA3B;AACAO,aAAOA,KAAKE,OAAZ;AACD;AACF;;AAED,WAASW,cAAT,CAAwB/B,OAAxB,EAA8C;AAE5C,QAAMU,SAASF,cAAcR,OAAd,CAAf;;AAEA8B,0BAAsBpB,MAAtB,EAA8BV,OAA9B;;AAOAA,YAAQW,MAAR,GAAiB,IAAjB;AACAX,YAAQsB,KAAR,GAAgB,IAAhB;AACA,QAAItB,QAAQgC,SAAZ,EAAuB;AACrBhC,cAAQgC,SAAR,CAAkBV,KAAlB,GAA0B,IAA1B;AACAtB,cAAQgC,SAAR,CAAkBrB,MAAlB,GAA2B,IAA3B;AACD;AACF;;AAKD,WAASkB,aAAT,CAAuB7B,OAAvB,EAA6C;AAC3C,QAAI,OAAOvB,eAAP,KAA2B,UAA/B,EAA2C;AACzCA,sBAAgBuB,OAAhB;AACD;;AAED,YAAQA,QAAQY,GAAhB;AACE,WAAK1C,cAAL;AAAqB;AACnBmC,0BAAgBL,OAAhB;AACA,cAAMC,WAAWD,QAAQa,SAAzB;AACA,cAAI,OAAOZ,SAASC,oBAAhB,KAAyC,UAA7C,EAAyD;AACvDC,2CAA+BH,OAA/B,EAAwCC,QAAxC;AACD;AACD;AACD;AACD,WAAK7B,aAAL;AAAoB;AAClBiC,0BAAgBL,OAAhB;AACA;AACD;AACD,WAAKzB,kBAAL;AAAyB;AACvBoD,+BAAqB3B,QAAQa,SAA7B;AACA;AACD;AACD,WAAKvC,UAAL;AAAiB;AAIf,cAAMoC,SAASF,cAAcR,OAAd,CAAf;AACA8B,gCAAsBpB,MAAtB,EAA8BV,OAA9B;AACA;AACD;AAxBH;AA0BD;;AAED,WAASiC,UAAT,CAAoBjC,OAApB,EAA2CwB,YAA3C,EAAsE;AACpE,YAAQA,aAAaZ,GAArB;AACE,WAAK1C,cAAL;AAAqB;AACnB;AACD;AACD,WAAKE,aAAL;AAAoB;AAClB,cAAM6B,WAAcuB,aAAaX,SAAjC;AACA,cAAIZ,YAAY,IAAZ,IAAoBD,YAAY,IAApC,EAA0C;AAExC,gBAAMkC,WAAWV,aAAaW,aAA9B;AACA,gBAAMC,WAAWpC,QAAQmC,aAAzB;AACA,gBAAME,OAAOb,aAAaa,IAA1B;;AAEA,gBAAMC,gBAA4Bd,aAAae,WAA/C;AACAf,yBAAae,WAAb,GAA2B,IAA3B;AACA,gBAAID,kBAAkB,IAAtB,EAA4B;AAC1B9C,2BACES,QADF,EAEEqC,aAFF,EAGED,IAHF,EAIED,QAJF,EAKEF,QALF,EAMEV,YANF;AAQD;AACF;AACD;AACD;AACD,WAAKnD,QAAL;AAAe;AACbU,oBACEyC,aAAaX,SAAb,KAA2B,IAA3B,IAAmCb,YAAY,IADjD,EAEE,mEACE,iDAHJ;AAKA,cAAMwC,eAAmBhB,aAAaX,SAAtC;AACA,cAAM4B,UAAkBjB,aAAaW,aAArC;AACA,cAAMO,UAAkB1C,QAAQmC,aAAhC;AACAzC,2BAAiB8C,YAAjB,EAA+BE,OAA/B,EAAwCD,OAAxC;AACA;AACD;AACD,WAAKtE,QAAL;AAAe;AACb;AACD;AACD,WAAKG,UAAL;AAAiB;AACf;AACD;AACD;AAAS;AACPS,oBACE,KADF,EAEE,uEACE,wDAHJ;AAKD;AAnDH;AAqDD;;AAED,WAAS4D,gBAAT,CAA0B3C,OAA1B,EAAiDwB,YAAjD,EAA4E;AAC1E,YAAQA,aAAaZ,GAArB;AACE,WAAK1C,cAAL;AAAqB;AACnB,cAAM+B,WAAWuB,aAAaX,SAA9B;AACA,cAAIW,aAAaH,SAAb,GAAyBzC,MAA7B,EAAqC;AACnC,gBAAIoB,YAAY,IAAhB,EAAsB;AACpB,kBAAIhB,OAAJ,EAAa;AACXC,gCAAgBuC,YAAhB,EAA8B,mBAA9B;AACD;AACDvB,uBAAS2C,iBAAT;AACA,kBAAI5D,OAAJ,EAAa;AACXE;AACD;AACF,aARD,MAQO;AACL,kBAAM2D,YAAY7C,QAAQmC,aAA1B;AACA,kBAAMW,YAAY9C,QAAQ+C,aAA1B;AACA,kBAAI/D,OAAJ,EAAa;AACXC,gCAAgBuC,YAAhB,EAA8B,oBAA9B;AACD;AACDvB,uBAAS+C,kBAAT,CAA4BH,SAA5B,EAAuCC,SAAvC;AACA,kBAAI9D,OAAJ,EAAa;AACXE;AACD;AACF;AACF;AACD,cACEsC,aAAaH,SAAb,GAAyBxC,QAAzB,IAAqC2C,aAAae,WAAb,KAA6B,IADpE,EAEE;AACA/D,4BAAgBgD,YAAhB,EAA8BA,aAAae,WAA3C,EAAwDtC,QAAxD;AACD;AACD;AACD;AACD,WAAK9B,QAAL;AAAe;AACb,cAAMoE,cAAcf,aAAae,WAAjC;AACA,cAAIA,gBAAgB,IAApB,EAA0B;AACxB,gBAAMtC,YAAWuB,aAAaF,KAAb,IAAsBE,aAAaF,KAAb,CAAmBT,SAA1D;AACArC,4BAAgBgD,YAAhB,EAA8Be,WAA9B,EAA2CtC,SAA3C;AACD;AACD;AACD;AACD,WAAK7B,aAAL;AAAoB;AAClB,cAAM6B,aAAcuB,aAAaX,SAAjC;;AAMA,cAAIb,YAAY,IAAZ,IAAoBwB,aAAaH,SAAb,GAAyBzC,MAAjD,EAAyD;AACvD,gBAAMyD,OAAOb,aAAaa,IAA1B;AACA,gBAAMY,QAAQzB,aAAaW,aAA3B;AACA5C,wBAAYU,UAAZ,EAAsBoC,IAAtB,EAA4BY,KAA5B,EAAmCzB,YAAnC;AACD;;AAED;AACD;AACD,WAAKnD,QAAL;AAAe;AAEb;AACD;AACD,WAAKC,UAAL;AAAiB;AAEf;AACD;AACD;AAAS;AACPS,oBACE,KADF,EAEE,uEACE,wDAHJ;AAKD;AApEH;AAsED;;AAED,WAASmE,eAAT,CAAyB1B,YAAzB,EAA8C;AAC5C,QAAMlB,MAAMkB,aAAalB,GAAzB;AACA,QAAIA,QAAQ,IAAZ,EAAkB;AAChB,UAAML,WAAWH,kBAAkB0B,aAAaX,SAA/B,CAAjB;AACAP,UAAIL,QAAJ;AACD;AACF;;AAED,WAASkD,eAAT,CAAyBnD,OAAzB,EAAyC;AACvC,QAAMoD,aAAapD,QAAQM,GAA3B;AACA,QAAI8C,eAAe,IAAnB,EAAyB;AACvBA,iBAAW,IAAX;AACD;AACF;;AAED,SAAO;AACL7B,oCADK;AAELQ,kCAFK;AAGLE,0BAHK;AAILU,sCAJK;AAKLO,oCALK;AAMLC;AANK,GAAP;AAQD,CA9eD","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberCommitWork\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\nimport type {HostConfig} from 'ReactFiberReconciler';\n\nvar ReactTypeOfWork = require('ReactTypeOfWork');\nvar {\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  CoroutineComponent,\n} = ReactTypeOfWork;\nvar {commitCallbacks} = require('ReactFiberUpdateQueue');\nvar {onCommitUnmount} = require('ReactFiberDevToolsHook');\nvar {invokeGuardedCallback} = require('ReactErrorUtils');\n\nvar {\n  Placement,\n  Update,\n  Callback,\n  ContentReset,\n} = require('ReactTypeOfSideEffect');\n\nvar invariant = require('fbjs/lib/invariant');\n\nif (__DEV__) {\n  var {\n    startPhaseTimer,\n    stopPhaseTimer,\n  } = require('ReactDebugFiberPerf');\n}\n\nmodule.exports = function<T, P, I, TI, PI, C, CX, PL>(\n  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,\n  captureError: (failedFiber: Fiber, error: Error) => Fiber | null,\n) {\n  const {\n    commitMount,\n    commitUpdate,\n    resetTextContent,\n    commitTextUpdate,\n    appendChild,\n    insertBefore,\n    removeChild,\n    getPublicInstance,\n  } = config;\n\n  if (__DEV__) {\n    var callComponentWillUnmountWithTimerInDev = function(current, instance) {\n      startPhaseTimer(current, 'componentWillUnmount');\n      instance.componentWillUnmount();\n      stopPhaseTimer();\n    };\n  }\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    if (__DEV__) {\n      const unmountError = invokeGuardedCallback(\n        null,\n        callComponentWillUnmountWithTimerInDev,\n        null,\n        current,\n        instance,\n      );\n      if (unmountError) {\n        captureError(current, unmountError);\n      }\n    } else {\n      try {\n        instance.componentWillUnmount();\n      } catch (unmountError) {\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current: Fiber) {\n    const ref = current.ref;\n    if (ref !== null) {\n      if (__DEV__) {\n        const refError = invokeGuardedCallback(null, ref, null, null);\n        if (refError !== null) {\n          captureError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function getHostParent(fiber: Fiber): I | C {\n    let parent = fiber.return;\n    while (parent !== null) {\n      switch (parent.tag) {\n        case HostComponent:\n          return parent.stateNode;\n        case HostRoot:\n          return parent.stateNode.containerInfo;\n        case HostPortal:\n          return parent.stateNode.containerInfo;\n      }\n      parent = parent.return;\n    }\n    invariant(\n      false,\n      'Expected to find a host parent. This error is likely caused by a bug ' +\n        'in React. Please file an issue.',\n    );\n  }\n\n  function getHostParentFiber(fiber: Fiber): Fiber {\n    let parent = fiber.return;\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent.return;\n    }\n    invariant(\n      false,\n      'Expected to find a host parent. This error is likely caused by a bug ' +\n        'in React. Please file an issue.',\n    );\n  }\n\n  function isHostParent(fiber: Fiber): boolean {\n    return fiber.tag === HostComponent ||\n      fiber.tag === HostRoot ||\n      fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber: Fiber): ?I {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    // TODO: Find a more efficient way to do this.\n    let node: Fiber = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node.return === null || isHostParent(node.return)) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child.return = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork: Fiber): void {\n    // Recursively insert all host nodes into the parent.\n    const parentFiber = getHostParentFiber(finishedWork);\n    let parent;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        break;\n      default:\n        invariant(\n          false,\n          'Invalid host parent fiber. This error is likely caused by a bug ' +\n            'in React. Please file an issue.',\n        );\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    const before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          insertBefore(parent, node.stateNode, before);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  function commitNestedUnmounts(root: Fiber): void {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    // we do an inner loop while we're still inside the host node.\n    let node: Fiber = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && node.tag !== HostPortal) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === root) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(parent, current): void {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = current;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        removeChild(parent, node.stateNode);\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        parent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === current) {\n          return;\n        }\n        node = node.return;\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          parent = getHostParent(node);\n        }\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current: Fiber): void {\n    // Recursively delete all host nodes from the parent.\n    const parent = getHostParent(current);\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(parent, current);\n\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current.return = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate.return = null;\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current: Fiber): void {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent: {\n        safelyDetachRef(current);\n        const instance = current.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, instance);\n        }\n        return;\n      }\n      case HostComponent: {\n        safelyDetachRef(current);\n        return;\n      }\n      case CoroutineComponent: {\n        commitNestedUnmounts(current.stateNode);\n        return;\n      }\n      case HostPortal: {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        const parent = getHostParent(current);\n        unmountHostComponents(parent, current);\n        return;\n      }\n    }\n  }\n\n  function commitWork(current: Fiber | null, finishedWork: Fiber): void {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        return;\n      }\n      case HostComponent: {\n        const instance: I = finishedWork.stateNode;\n        if (instance != null && current !== null) {\n          // Commit the work prepared earlier.\n          const newProps = finishedWork.memoizedProps;\n          const oldProps = current.memoizedProps;\n          const type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          const updatePayload: null | PL = (finishedWork.updateQueue: any);\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(\n              instance,\n              updatePayload,\n              type,\n              oldProps,\n              newProps,\n              finishedWork,\n            );\n          }\n        }\n        return;\n      }\n      case HostText: {\n        invariant(\n          finishedWork.stateNode !== null && current !== null,\n          'This should only be done during updates. This error is likely ' +\n            'caused by a bug in React. Please file an issue.',\n        );\n        const textInstance: TI = finishedWork.stateNode;\n        const newText: string = finishedWork.memoizedProps;\n        const oldText: string = current.memoizedProps;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n      case HostRoot: {\n        return;\n      }\n      case HostPortal: {\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n  }\n\n  function commitLifeCycles(current: Fiber | null, finishedWork: Fiber): void {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        const instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            if (__DEV__) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n            }\n            instance.componentDidMount();\n            if (__DEV__) {\n              stopPhaseTimer();\n            }\n          } else {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            if (__DEV__) {\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n            }\n            instance.componentDidUpdate(prevProps, prevState);\n            if (__DEV__) {\n              stopPhaseTimer();\n            }\n          }\n        }\n        if (\n          finishedWork.effectTag & Callback && finishedWork.updateQueue !== null\n        ) {\n          commitCallbacks(finishedWork, finishedWork.updateQueue, instance);\n        }\n        return;\n      }\n      case HostRoot: {\n        const updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          const instance = finishedWork.child && finishedWork.child.stateNode;\n          commitCallbacks(finishedWork, updateQueue, instance);\n        }\n        return;\n      }\n      case HostComponent: {\n        const instance: I = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          const type = finishedWork.type;\n          const props = finishedWork.memoizedProps;\n          commitMount(instance, type, props, finishedWork);\n        }\n\n        return;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        return;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n  }\n\n  function commitAttachRef(finishedWork: Fiber) {\n    const ref = finishedWork.ref;\n    if (ref !== null) {\n      const instance = getPublicInstance(finishedWork.stateNode);\n      ref(instance);\n    }\n  }\n\n  function commitDetachRef(current: Fiber) {\n    const currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  return {\n    commitPlacement,\n    commitDeletion,\n    commitWork,\n    commitLifeCycles,\n    commitAttachRef,\n    commitDetachRef,\n  };\n};\n"]}]