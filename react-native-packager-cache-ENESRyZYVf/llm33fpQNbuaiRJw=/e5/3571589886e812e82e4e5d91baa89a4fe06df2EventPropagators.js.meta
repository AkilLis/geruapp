["1ab4fdb00ab5c64330f1a9ef9386a932236689d2","d1d85d26dc45190102d2d23b7f194fb1bfc7ed88",["EventPluginHub","ReactTreeTraversal","accumulateInto","forEachAccumulated","fbjs/lib/warning"],[46,98,151,203,248],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/shared/event/EventPropagators.js"],"names":["EventPluginHub","require","ReactTreeTraversal","accumulateInto","forEachAccumulated","warning","getListener","listenerAtPhase","inst","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","__DEV__","listener","_dispatchListeners","_dispatchInstances","accumulateTwoPhaseDispatchesSingle","traverseTwoPhase","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","getParentInstance","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","from","to","traverseEnterLeave","accumulateDirectDispatches","EventPropagators","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventPluginHub = require('EventPluginHub');\nvar ReactTreeTraversal = require('ReactTreeTraversal');\n\nvar accumulateInto = require('accumulateInto');\nvar forEachAccumulated = require('forEachAccumulated');\nvar warning = require('fbjs/lib/warning');\n\nimport type {PropagationPhases} from 'EventConstants';\n\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase: PropagationPhases) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[\n    propagationPhase\n  ];\n  return getListener(inst, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (__DEV__) {\n    warning(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener,\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    ReactTreeTraversal.traverseTwoPhase(\n      event._targetInst,\n      accumulateDirectionalDispatches,\n      event,\n    );\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst\n      ? ReactTreeTraversal.getParentInstance(targetInst)\n      : null;\n    ReactTreeTraversal.traverseTwoPhase(\n      parentInst,\n      accumulateDirectionalDispatches,\n      event,\n    );\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener,\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  ReactTreeTraversal.traverseEnterLeave(\n    from,\n    to,\n    accumulateDispatches,\n    leave,\n    enter,\n  );\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n};\n\nmodule.exports = EventPropagators;\n"]}]