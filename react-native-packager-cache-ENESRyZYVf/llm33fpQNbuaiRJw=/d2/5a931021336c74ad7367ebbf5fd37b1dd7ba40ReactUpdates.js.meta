["679805464a797338c9854a880d2f1b1460361757","f5808621bfa0f47d8fcc7e1cc169d096e6b53cbf",["PooledClass","ReactFeatureFlags","ReactReconciler","Transaction","fbjs/lib/invariant"],[43,91,143,189,230],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/stack/reconciler/ReactUpdates.js"],"names":["PooledClass","require","ReactFeatureFlags","ReactReconciler","Transaction","invariant","dirtyComponents","updateBatchNumber","batchingStrategy","ensureInjected","ReactUpdates","ReactReconcileTransaction","NESTED_UPDATES","initialize","dirtyComponentsLength","length","close","splice","flushBatchedUpdates","TRANSACTION_WRAPPERS","ReactUpdatesFlushTransaction","reinitializeTransaction","reconcileTransaction","getPooled","prototype","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","batchedUpdates","callback","b","c","d","e","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","sort","i","component","markerName","logTopLevelRenders","namedComponent","_currentElement","type","isReactTopLevelWrapper","_renderedComponent","getName","console","time","performUpdateIfNecessary","timeEnd","enqueueUpdate","isBatchingUpdates","push","_updateBatchNumber","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","getBatchingStrategy","injection","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar PooledClass = require('PooledClass');\nvar ReactFeatureFlags = require('ReactFeatureFlags');\nvar ReactReconciler = require('ReactReconciler');\nvar Transaction = require('Transaction');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar updateBatchNumber = 0;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  invariant(\n    ReactUpdates.ReactReconcileTransaction && batchingStrategy,\n    'ReactUpdates: must inject a reconcile transaction class and batching ' +\n      'strategy',\n  );\n}\n\nvar NESTED_UPDATES = {\n  initialize: function() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  },\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(\n    /* useCreateElement */ true,\n  );\n}\n\nObject.assign(ReactUpdatesFlushTransaction.prototype, Transaction, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function() {\n    this.dirtyComponentsLength = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.perform.call(\n      this,\n      this.reconcileTransaction.perform,\n      this.reconcileTransaction,\n      method,\n      scope,\n      a,\n    );\n  },\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  invariant(\n    len === dirtyComponents.length,\n    \"Expected flush transaction's stored dirty-components length (%s) to \" +\n      'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length,\n  );\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    var markerName;\n    if (ReactFeatureFlags.logTopLevelRenders) {\n      var namedComponent = component;\n      // Duck type TopLevelWrapper. This is probably always true.\n      if (component._currentElement.type.isReactTopLevelWrapper) {\n        namedComponent = component._renderedComponent;\n      }\n      markerName = 'React update: ' + namedComponent.getName();\n      console.time(markerName);\n    }\n\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction,\n      updateBatchNumber,\n    );\n\n    if (markerName) {\n      console.timeEnd(markerName);\n    }\n  }\n}\n\nvar flushBatchedUpdates = function() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks.\n  while (dirtyComponents.length) {\n    var transaction = ReactUpdatesFlushTransaction.getPooled();\n    transaction.perform(runBatchedUpdates, null, transaction);\n    ReactUpdatesFlushTransaction.release(transaction);\n  }\n};\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class',\n    );\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy',\n    );\n    invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function',\n    );\n    invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute',\n    );\n    batchingStrategy = _batchingStrategy;\n  },\n\n  getBatchingStrategy: function() {\n    return batchingStrategy;\n  },\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n};\n\nmodule.exports = ReactUpdates;\n"]}]