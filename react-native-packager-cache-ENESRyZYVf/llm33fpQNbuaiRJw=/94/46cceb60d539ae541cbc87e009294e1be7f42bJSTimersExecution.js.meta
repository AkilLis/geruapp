["0f56acb6ed37d8918312111f73eca96c13b8fa6a","62f1824aa17a990567a8c46c80b903df8601f88a",["Systrace","fbjs/lib/invariant","fbjs/lib/performanceNow","fbjs/lib/warning","JSTimers","NativeModules"],[39,77,129,179,2594,3391,3609,4453],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Core/Timers/JSTimersExecution.js"],"names":["Systrace","require","invariant","performanceNow","warning","FRAME_DURATION","IDLE_CALLBACK_FRAME_DEADLINE","hasEmittedTimeDriftWarning","JSTimersExecution","GUID","callbacks","types","timerIDs","immediates","requestIdleCallbacks","identifiers","errors","callTimer","timerID","frameTime","timerIndex","indexOf","type","callback","console","error","__DEV__","identifier","beginEvent","methodName","_clearIndex","timeRemaining","Math","max","e","push","endEvent","callTimers","length","i","errorCount","ii","setTimeout","bind","callIdleCallbacks","passIdleCallbacks","slice","Timing","setSendIdleEvents","forEach","callImmediatesPass","passImmediates","callImmediates","emitTimeDriftWarning","warningMessage","warn","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule JSTimersExecution\n * @flow\n */\n'use strict';\n\nconst Systrace = require('Systrace');\n\nconst invariant = require('fbjs/lib/invariant');\nconst performanceNow = require('fbjs/lib/performanceNow');\nconst warning = require('fbjs/lib/warning');\n\n// These timing contants should be kept in sync with the ones in native ios and\n// android `RCTTiming` module.\nconst FRAME_DURATION = 1000 / 60;\nconst IDLE_CALLBACK_FRAME_DEADLINE = 1;\n\nlet hasEmittedTimeDriftWarning = false;\n\nexport type JSTimerType =\n  'setTimeout' |\n  'setInterval' |\n  'requestAnimationFrame' |\n  'setImmediate' |\n  'requestIdleCallback';\n\n/**\n * JS implementation of timer functions. Must be completely driven by an\n * external clock signal, all that's stored here is timerID, timer type, and\n * callback.\n */\nconst JSTimersExecution = {\n  GUID: 1,\n\n  // Parallel arrays\n  callbacks: ([] : Array<?Function>),\n  types: ([] : Array<?JSTimerType>),\n  timerIDs: ([] : Array<?number>),\n  immediates: [],\n  requestIdleCallbacks: [],\n  identifiers: ([] : Array<null | {methodName: string}>),\n\n  errors: (null : ?Array<Error>),\n\n  /**\n   * Calls the callback associated with the ID. Also unregister that callback\n   * if it was a one time timer (setTimeout), and not unregister it if it was\n   * recurring (setInterval).\n   */\n  callTimer(timerID: number, frameTime: number) {\n    warning(\n      timerID <= JSTimersExecution.GUID,\n      'Tried to call timer with ID %s but no such timer exists.',\n      timerID\n    );\n\n    // timerIndex of -1 means that no timer with that ID exists. There are\n    // two situations when this happens, when a garbage timer ID was given\n    // and when a previously existing timer was deleted before this callback\n    // fired. In both cases we want to ignore the timer id, but in the former\n    // case we warn as well.\n    const timerIndex = JSTimersExecution.timerIDs.indexOf(timerID);\n    if (timerIndex === -1) {\n      return;\n    }\n\n    const type = JSTimersExecution.types[timerIndex];\n    const callback = JSTimersExecution.callbacks[timerIndex];\n    if (!callback || !type) {\n      console.error('No callback found for timerID ' + timerID);\n      return;\n    }\n\n    if (__DEV__) {\n      const identifier = JSTimersExecution.identifiers[timerIndex] || {};\n      Systrace.beginEvent('Systrace.callTimer: ' + identifier.methodName);\n    }\n\n    // Clear the metadata\n    if (type === 'setTimeout' || type === 'setImmediate' ||\n        type === 'requestAnimationFrame' || type === 'requestIdleCallback') {\n      JSTimersExecution._clearIndex(timerIndex);\n    }\n\n    try {\n      if (type === 'setTimeout' || type === 'setInterval' ||\n          type === 'setImmediate') {\n        callback();\n      } else if (type === 'requestAnimationFrame') {\n        callback(performanceNow());\n      } else if (type === 'requestIdleCallback') {\n        callback({\n          timeRemaining: function() {\n            // TODO: Optimisation: allow running for longer than one frame if\n            // there are no pending JS calls on the bridge from native. This\n            // would require a way to check the bridge queue synchronously.\n            return Math.max(0, FRAME_DURATION - (performanceNow() - frameTime));\n          },\n        });\n      } else {\n        console.error('Tried to call a callback with invalid type: ' + type);\n      }\n    } catch (e) {\n      // Don't rethrow so that we can run all timers.\n      if (!JSTimersExecution.errors) {\n        JSTimersExecution.errors = [e];\n      } else {\n        JSTimersExecution.errors.push(e);\n      }\n    }\n\n    if (__DEV__) {\n      Systrace.endEvent();\n    }\n  },\n\n  /**\n   * This is called from the native side. We are passed an array of timerIDs,\n   * and\n   */\n  callTimers(timerIDs: [number]) {\n    invariant(\n      timerIDs.length !== 0,\n      'Cannot call `callTimers` with an empty list of IDs.'\n    );\n\n    JSTimersExecution.errors = null;\n    for (let i = 0; i < timerIDs.length; i++) {\n      JSTimersExecution.callTimer(timerIDs[i], 0);\n    }\n\n    const errors = JSTimersExecution.errors;\n    if (errors) {\n      const errorCount = errors.length;\n      if (errorCount > 1) {\n        // Throw all the other errors in a setTimeout, which will throw each\n        // error one at a time\n        for (let ii = 1; ii < errorCount; ii++) {\n          require('JSTimers').setTimeout(\n            ((error) => { throw error; }).bind(null, errors[ii]),\n            0\n          );\n        }\n      }\n      throw errors[0];\n    }\n  },\n\n  callIdleCallbacks: function(frameTime: number) {\n    if (FRAME_DURATION - (performanceNow() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {\n      return;\n    }\n\n    JSTimersExecution.errors = null;\n    if (JSTimersExecution.requestIdleCallbacks.length > 0) {\n      const passIdleCallbacks = JSTimersExecution.requestIdleCallbacks.slice();\n      JSTimersExecution.requestIdleCallbacks = [];\n\n      for (let i = 0; i < passIdleCallbacks.length; ++i) {\n        JSTimersExecution.callTimer(passIdleCallbacks[i], frameTime);\n      }\n    }\n\n    if (JSTimersExecution.requestIdleCallbacks.length === 0) {\n      const { Timing } = require('NativeModules');\n      Timing.setSendIdleEvents(false);\n    }\n\n    if (JSTimersExecution.errors) {\n      JSTimersExecution.errors.forEach((error) =>\n        require('JSTimers').setTimeout(() => { throw error; }, 0)\n      );\n    }\n  },\n\n  /**\n   * Performs a single pass over the enqueued immediates. Returns whether\n   * more immediates are queued up (can be used as a condition a while loop).\n   */\n  callImmediatesPass() {\n    Systrace.beginEvent('JSTimersExecution.callImmediatesPass()');\n\n    // The main reason to extract a single pass is so that we can track\n    // in the system trace\n    if (JSTimersExecution.immediates.length > 0) {\n      const passImmediates = JSTimersExecution.immediates.slice();\n      JSTimersExecution.immediates = [];\n\n      // Use for loop rather than forEach as per @vjeux's advice\n      // https://github.com/facebook/react-native/commit/c8fd9f7588ad02d2293cac7224715f4af7b0f352#commitcomment-14570051\n      for (let i = 0; i < passImmediates.length; ++i) {\n        JSTimersExecution.callTimer(passImmediates[i], 0);\n      }\n    }\n\n    Systrace.endEvent();\n\n    return JSTimersExecution.immediates.length > 0;\n  },\n\n  /**\n   * This is called after we execute any command we receive from native but\n   * before we hand control back to native.\n   */\n  callImmediates() {\n    JSTimersExecution.errors = null;\n    while (JSTimersExecution.callImmediatesPass()) {}\n    if (JSTimersExecution.errors) {\n      JSTimersExecution.errors.forEach((error) =>\n        require('JSTimers').setTimeout(() => { throw error; }, 0)\n      );\n    }\n  },\n\n  /**\n   * Called from native (in development) when environment times are out-of-sync.\n   */\n  emitTimeDriftWarning(warningMessage: string) {\n    if (hasEmittedTimeDriftWarning) {\n      return;\n    }\n    hasEmittedTimeDriftWarning = true;\n    console.warn(warningMessage);\n  },\n\n  _clearIndex(i: number) {\n    JSTimersExecution.timerIDs[i] = null;\n    JSTimersExecution.callbacks[i] = null;\n    JSTimersExecution.types[i] = null;\n    JSTimersExecution.identifiers[i] = null;\n  },\n};\n\nmodule.exports = JSTimersExecution;\n"]}]