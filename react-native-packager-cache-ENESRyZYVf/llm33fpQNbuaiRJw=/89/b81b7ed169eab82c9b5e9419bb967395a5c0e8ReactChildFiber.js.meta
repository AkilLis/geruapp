["6738c345b08dd122b727f052763ef93048ba8d5d","490364122bd4c469dfe413966b6bb8fdeee0ba7d",["ReactElementSymbol","ReactCoroutine","ReactPortal","ReactFiber","ReactTypeOfSideEffect","ReactTypeOfWork","fbjs/lib/emptyObject","getIteratorFn","fbjs/lib/invariant","ReactFeatureFlags","react/lib/ReactCurrentOwner","ReactDebugCurrentFiber","getComponentName","fbjs/lib/warning"],[50,97,249,344,395,451,498,551,593,648,702,776,914,959],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactChildFiber.js"],"names":["REACT_ELEMENT_TYPE","require","REACT_COROUTINE_TYPE","REACT_YIELD_TYPE","REACT_PORTAL_TYPE","ReactFiber","ReactTypeOfSideEffect","ReactTypeOfWork","emptyObject","getIteratorFn","invariant","ReactFeatureFlags","ReactCurrentOwner","__DEV__","getCurrentFiberStackAddendum","getComponentName","warning","didWarnAboutMaps","cloneFiber","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromCoroutine","createFiberFromYield","createFiberFromPortal","isArray","Array","FunctionalComponent","ClassComponent","HostText","HostPortal","CoroutineComponent","YieldComponent","Fragment","NoEffect","Placement","Deletion","coerceRef","current","element","mixedRef","ref","_owner","owner","inst","tag","ownerFiber","stateNode","getPublicInstance","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","returnFiber","newChild","type","addendum","_debugOwner","name","Object","prototype","toString","call","keys","join","ChildReconciler","shouldClone","shouldTrackSideEffects","deleteChild","childToDelete","alternate","last","progressedLastDeletion","nextEffect","progressedFirstDeletion","effectTag","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","key","set","index","useFiber","fiber","priority","clone","pendingWorkPriority","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","return","existing","pendingProps","updateElement","props","_debugSource","_source","updateCoroutine","coroutine","updateYield","yieldNode","updatePortal","portal","containerInfo","implementation","children","updateFragment","fragment","createChild","$$typeof","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnDuplicateKey","child","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","possibleMap","mapsAsChildrenAddendum","mapsAsChildrenOwnerName","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSingleCoroutine","reconcileSingleYield","reconcileSinglePortal","reconcileChildFibers","disableNewFiberFeatures","isObject","instance","render","_isMockFunction","Component","displayName","exports","reconcileChildFibersInPlace","mountChildFibersInPlace","cloneChildFibers","workInProgress","currentChild"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildFiber\n * @flow\n */\n\n'use strict';\n\nimport type {ReactElement} from 'ReactElementType';\nimport type {ReactCoroutine, ReactYield} from 'ReactCoroutine';\nimport type {ReactPortal} from 'ReactPortal';\nimport type {Fiber} from 'ReactFiber';\nimport type {ReactInstance} from 'ReactInstanceType';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\n\nvar REACT_ELEMENT_TYPE = require('ReactElementSymbol');\nvar {\n  REACT_COROUTINE_TYPE,\n  REACT_YIELD_TYPE,\n} = require('ReactCoroutine');\nvar {\n  REACT_PORTAL_TYPE,\n} = require('ReactPortal');\n\nvar ReactFiber = require('ReactFiber');\nvar ReactTypeOfSideEffect = require('ReactTypeOfSideEffect');\nvar ReactTypeOfWork = require('ReactTypeOfWork');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar getIteratorFn = require('getIteratorFn');\nvar invariant = require('fbjs/lib/invariant');\nvar ReactFeatureFlags = require('ReactFeatureFlags');\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\n\nif (__DEV__) {\n  var {getCurrentFiberStackAddendum} = require('ReactDebugCurrentFiber');\n  var getComponentName = require('getComponentName');\n  var warning = require('fbjs/lib/warning');\n  var didWarnAboutMaps = false;\n}\n\nconst {\n  cloneFiber,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromCoroutine,\n  createFiberFromYield,\n  createFiberFromPortal,\n} = ReactFiber;\n\nconst isArray = Array.isArray;\n\nconst {\n  FunctionalComponent,\n  ClassComponent,\n  HostText,\n  HostPortal,\n  CoroutineComponent,\n  YieldComponent,\n  Fragment,\n} = ReactTypeOfWork;\n\nconst {\n  NoEffect,\n  Placement,\n  Deletion,\n} = ReactTypeOfSideEffect;\n\nfunction coerceRef(current: Fiber | null, element: ReactElement) {\n  let mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      const owner: ?(Fiber | ReactInstance) = (element._owner: any);\n      let inst;\n      if (owner) {\n        if (typeof owner.tag === 'number') {\n          const ownerFiber = ((owner: any): Fiber);\n          invariant(\n            ownerFiber.tag === ClassComponent,\n            'Stateless function components cannot have refs.',\n          );\n          inst = ownerFiber.stateNode;\n        } else {\n          // Stack\n          inst = (owner: any).getPublicInstance();\n        }\n      }\n      invariant(\n        inst,\n        'Missing owner for string ref %s. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n        mixedRef,\n      );\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function(value) {\n        const refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n    if (__DEV__) {\n      addendum = ' If you meant to render a collection of children, use an array ' +\n        'instead.';\n      const owner = ReactCurrentOwner.owner || returnFiber._debugOwner;\n      if (owner && typeof owner.tag === 'number') {\n        const name = getComponentName((owner: any));\n        if (name) {\n          addendum += '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n    }\n    invariant(\n      false,\n      'Objects are not valid as a React child (found: %s).%s',\n      Object.prototype.toString.call(newChild) === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : newChild,\n      addendum,\n    );\n  }\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldClone, shouldTrackSideEffects) {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    if (!shouldClone) {\n      // When we're reconciling in place we have a work in progress copy. We\n      // actually want the current copy. If there is no current copy, then we\n      // don't need to track deletion side-effects.\n      if (childToDelete.alternate === null) {\n        return;\n      }\n      childToDelete = childToDelete.alternate;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    const last = returnFiber.progressedLastDeletion;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.progressedLastDeletion = childToDelete;\n    } else {\n      returnFiber.progressedFirstDeletion = (returnFiber.progressedLastDeletion = childToDelete);\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber: Fiber, priority: PriorityLevel): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    if (shouldClone) {\n      const clone = cloneFiber(fiber, priority);\n      clone.index = 0;\n      clone.sibling = null;\n      return clone;\n    } else {\n      // We override the pending priority even if it is higher, because if\n      // we're reconciling at a lower priority that means that this was\n      // down-prioritized.\n      fiber.pendingWorkPriority = priority;\n      fiber.effectTag = NoEffect;\n      fiber.index = 0;\n      fiber.sibling = null;\n      return fiber;\n    }\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    const current = newFiber.alternate;\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    priority: PriorityLevel,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, priority);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, priority);\n      existing.pendingProps = textContent;\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    priority: PriorityLevel,\n  ): Fiber {\n    if (current === null || current.type !== element.type) {\n      // Insert\n      const created = createFiberFromElement(element, priority);\n      created.ref = coerceRef(current, element);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      const existing = useFiber(current, priority);\n      existing.ref = coerceRef(current, element);\n      existing.pendingProps = element.props;\n      existing.return = returnFiber;\n      if (__DEV__) {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    }\n  }\n\n  function updateCoroutine(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    coroutine: ReactCoroutine,\n    priority: PriorityLevel,\n  ): Fiber {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CoroutineComponent) {\n      // Insert\n      const created = createFiberFromCoroutine(coroutine, priority);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      const existing = useFiber(current, priority);\n      existing.pendingProps = coroutine;\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateYield(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    yieldNode: ReactYield,\n    priority: PriorityLevel,\n  ): Fiber {\n    if (current === null || current.tag !== YieldComponent) {\n      // Insert\n      const created = createFiberFromYield(yieldNode, priority);\n      created.type = yieldNode.value;\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      const existing = useFiber(current, priority);\n      existing.type = yieldNode.value;\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    priority: PriorityLevel,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(portal, priority);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, priority);\n      existing.pendingProps = portal.children || [];\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<*>,\n    priority: PriorityLevel,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, priority);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, priority);\n      existing.pendingProps = fragment;\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, priority);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(newChild, priority);\n          created.ref = coerceRef(null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n\n        case REACT_COROUTINE_TYPE: {\n          const created = createFiberFromCoroutine(newChild, priority);\n          created.return = returnFiber;\n          return created;\n        }\n\n        case REACT_YIELD_TYPE: {\n          const created = createFiberFromYield(newChild, priority);\n          created.type = newChild.value;\n          created.return = returnFiber;\n          return created;\n        }\n\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(newChild, priority);\n          created.return = returnFiber;\n          return created;\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, priority);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, priority);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            return updateElement(returnFiber, oldFiber, newChild, priority);\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_COROUTINE_TYPE: {\n          if (newChild.key === key) {\n            return updateCoroutine(returnFiber, oldFiber, newChild, priority);\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_YIELD_TYPE: {\n          // Yields doesn't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a\n          // yield.\n          if (key === null) {\n            return updateYield(returnFiber, oldFiber, newChild, priority);\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(returnFiber, oldFiber, newChild, priority);\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        // Fragments doesn't have keys so if the previous key is implicit we can\n        // update it.\n        if (key !== null) {\n          return null;\n        }\n        return updateFragment(returnFiber, oldFiber, newChild, priority);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes doesn't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, priority);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber = existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n          return updateElement(returnFiber, matchedFiber, newChild, priority);\n        }\n\n        case REACT_COROUTINE_TYPE: {\n          const matchedFiber = existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n          return updateCoroutine(returnFiber, matchedFiber, newChild, priority);\n        }\n\n        case REACT_YIELD_TYPE: {\n          // Yields doesn't have keys, so we neither have to check the old nor\n          // new node for the key. If both are yields, they match.\n          const matchedFiber = existingChildren.get(newIdx) || null;\n          return updateYield(returnFiber, matchedFiber, newChild, priority);\n        }\n\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber = existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n          return updatePortal(returnFiber, matchedFiber, newChild, priority);\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, priority);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    return null;\n  }\n\n  function warnOnDuplicateKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_COROUTINE_TYPE:\n        case REACT_PORTAL_TYPE:\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            'Encountered two children with the same key, ' +\n              '`%s`. Child keys must be unique; when two children share a key, ' +\n              'only the first child will be used.%s',\n            key,\n            getCurrentFiberStackAddendum(),\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<*>,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnDuplicateKey(child, knownKeys);\n      }\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        priority,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          priority,\n        );\n        if (!newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        priority,\n      );\n      if (newFiber) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<*>,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === 'function',\n      'An object is not an iterable. This error is likely caused by a bug in ' +\n        'React. Please file an issue.',\n    );\n\n    if (__DEV__) {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        const possibleMap = (newChildrenIterable: any);\n        if (possibleMap.entries === iteratorFn) {\n          let mapsAsChildrenAddendum = '';\n          const owner = ReactCurrentOwner.owner || returnFiber._debugOwner;\n          if (owner && typeof owner.tag === 'number') {\n            const mapsAsChildrenOwnerName = getComponentName((owner: any));\n            if (mapsAsChildrenOwnerName) {\n              mapsAsChildrenAddendum = '\\n\\nCheck the render method of `' +\n                mapsAsChildrenOwnerName +\n                '`.';\n            }\n          }\n          warning(\n            didWarnAboutMaps,\n            'Using Maps as children is unsupported and will likely yield ' +\n              'unexpected results. Convert it to a sequence/iterable of keyed ' +\n              'ReactElements instead.%s',\n            mapsAsChildrenAddendum,\n          );\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnDuplicateKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, (step = newChildren.next())\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, priority);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, (step = newChildren.next())) {\n        const newFiber = createChild(returnFiber, step.value, priority);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, (step = newChildren.next())) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        priority,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    priority: PriorityLevel,\n  ): Fiber {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, priority);\n      existing.pendingProps = textContent;\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, priority);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    priority: PriorityLevel,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, priority);\n          existing.ref = coerceRef(child, element);\n          existing.pendingProps = element.props;\n          existing.return = returnFiber;\n          if (__DEV__) {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromElement(element, priority);\n    created.ref = coerceRef(currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleCoroutine(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    coroutine: ReactCoroutine,\n    priority: PriorityLevel,\n  ): Fiber {\n    const key = coroutine.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CoroutineComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, priority);\n          existing.pendingProps = coroutine;\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromCoroutine(coroutine, priority);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleYield(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    yieldNode: ReactYield,\n    priority: PriorityLevel,\n  ): Fiber {\n    // There's no need to check for keys on yields since they're stateless.\n    let child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === YieldComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        const existing = useFiber(child, priority);\n        existing.type = yieldNode.value;\n        existing.return = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    const created = createFiberFromYield(yieldNode, priority);\n    created.type = yieldNode.value;\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    priority: PriorityLevel,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, priority);\n          existing.pendingProps = portal.children || [];\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, priority);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    priority: PriorityLevel,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    const disableNewFiberFeatures = ReactFeatureFlags.disableNewFiberFeatures;\n\n    // Handle object types\n    const isObject = typeof newChild === 'object' && newChild !== null;\n    if (isObject) {\n      // Support only the subset of return types that Stack supports. Treat\n      // everything else as empty, but log a warning.\n      if (disableNewFiberFeatures) {\n        switch (newChild.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            return placeSingleChild(\n              reconcileSingleElement(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n\n          case REACT_PORTAL_TYPE:\n            return placeSingleChild(\n              reconcileSinglePortal(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n        }\n      } else {\n        switch (newChild.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n            return placeSingleChild(\n              reconcileSingleElement(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n\n          case REACT_COROUTINE_TYPE:\n            return placeSingleChild(\n              reconcileSingleCoroutine(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n\n          case REACT_YIELD_TYPE:\n            return placeSingleChild(\n              reconcileSingleYield(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n\n          case REACT_PORTAL_TYPE:\n            return placeSingleChild(\n              reconcileSinglePortal(\n                returnFiber,\n                currentFirstChild,\n                newChild,\n                priority,\n              ),\n            );\n        }\n      }\n    }\n\n    if (disableNewFiberFeatures) {\n      // The new child is not an element. If it's not null or false,\n      // and the return fiber is a composite component, throw an error.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          if (__DEV__) {\n            const instance = returnFiber.stateNode;\n            if (\n              instance.render._isMockFunction && typeof newChild === 'undefined'\n            ) {\n              // We allow auto-mocks to proceed as if they're\n              // returning null.\n              break;\n            }\n          }\n          const Component = returnFiber.type;\n          invariant(\n            newChild === null || newChild === false,\n            '%s.render(): A valid React element (or null) must be returned. ' +\n              'You may have returned undefined, an array or some other ' +\n              'invalid object.',\n            Component.displayName || Component.name || 'Component',\n          );\n          break;\n        }\n        case FunctionalComponent: {\n          // Composites accept elements, portals, null, or false\n          const Component = returnFiber.type;\n          invariant(\n            newChild === null || newChild === false,\n            '%s(...): A valid React element (or null) must be returned. ' +\n              'You may have returned undefined, an array or some other ' +\n              'invalid object.',\n            Component.displayName || Component.name || 'Component',\n          );\n          break;\n        }\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          priority,\n        ),\n      );\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        priority,\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        priority,\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (!disableNewFiberFeatures && typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          if (__DEV__) {\n            const instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          const Component = returnFiber.type;\n          invariant(\n            false,\n            '%s(...): Nothing was returned from render. This usually means a ' +\n              'return statement is missing. Or, to render nothing, ' +\n              'return null.',\n            Component.displayName || Component.name || 'Component',\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexports.reconcileChildFibers = ChildReconciler(true, true);\n\nexports.reconcileChildFibersInPlace = ChildReconciler(false, true);\n\nexports.mountChildFibersInPlace = ChildReconciler(false, false);\n\nexports.cloneChildFibers = function(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  if (!workInProgress.child) {\n    return;\n  }\n  if (current !== null && workInProgress.child === current.child) {\n    // We use workInProgress.child since that lets Flow know that it can't be\n    // null since we validated that already. However, as the line above suggests\n    // they're actually the same thing.\n    let currentChild = workInProgress.child;\n    // TODO: This used to reset the pending priority. Not sure if that is needed.\n    // workInProgress.pendingWorkPriority = current.pendingWorkPriority;\n    // TODO: The below priority used to be set to NoWork which would've\n    // dropped work. This is currently unobservable but will become\n    // observable when the first sibling has lower priority work remaining\n    // than the next sibling. At that point we should add tests that catches\n    // this.\n    let newChild = cloneFiber(currentChild, currentChild.pendingWorkPriority);\n    workInProgress.child = newChild;\n\n    newChild.return = workInProgress;\n    while (currentChild.sibling !== null) {\n      currentChild = currentChild.sibling;\n      newChild = (newChild.sibling = cloneFiber(\n        currentChild,\n        currentChild.pendingWorkPriority,\n      ));\n      newChild.return = workInProgress;\n    }\n    newChild.sibling = null;\n  } else {\n    // If there is no alternate, then we don't need to clone the children.\n    // If the children of the alternate fiber is a different set, then we don't\n    // need to clone. We need to reset the return fiber though since we'll\n    // traverse down into them.\n    let child = workInProgress.child;\n    while (child !== null) {\n      child.return = workInProgress;\n      child = child.sibling;\n    }\n  }\n};\n"]}]