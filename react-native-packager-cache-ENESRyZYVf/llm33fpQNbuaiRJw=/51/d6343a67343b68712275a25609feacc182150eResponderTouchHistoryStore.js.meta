["b83813f2eba7da60055e63e3549121ea6fb37d55","09ce3becadb1e060b9249ab89213da9c64b4f21c",["EventPluginUtils","fbjs/lib/invariant","fbjs/lib/warning"],[48,94,139],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/shared/event/eventPlugins/ResponderTouchHistoryStore.js"],"names":["EventPluginUtils","require","invariant","warning","isEndish","isMoveish","isStartish","MAX_TOUCH_BANK","touchBank","touchHistory","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","identifier","recordTouchStart","recordTouchMove","console","error","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","__DEV__","activeRecord","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ResponderTouchHistoryStore\n * @flow\n */\n\n'use strict';\n\nconst EventPluginUtils = require('EventPluginUtils');\n\nconst invariant = require('fbjs/lib/invariant');\nconst warning = require('fbjs/lib/warning');\n\nconst {\n  isEndish,\n  isMoveish,\n  isStartish,\n} = EventPluginUtils;\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\ntype TouchRecord = {\n  touchActive: boolean,\n  startPageX: number,\n  startPageY: number,\n  startTimeStamp: number,\n  currentPageX: number,\n  currentPageY: number,\n  currentTimeStamp: number,\n  previousPageX: number,\n  previousPageY: number,\n  previousTimeStamp: number,\n};\n\nconst MAX_TOUCH_BANK = 20;\nconst touchBank: Array<TouchRecord> = [];\nconst touchHistory = {\n  touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0,\n};\n\ntype Touch = {\n  identifier: ?number,\n  pageX: number,\n  pageY: number,\n  timestamp: number,\n};\ntype TouchEvent = {\n  changedTouches: Array<Touch>,\n  touches: Array<Touch>,\n};\n\nfunction timestampForTouch(touch: Touch): number {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return (touch: any).timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch: Touch): TouchRecord {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch),\n  };\n}\n\nfunction resetTouchRecord(touchRecord: TouchRecord, touch: Touch): void {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier({identifier}: Touch): number {\n  invariant(identifier != null, 'Touch object is missing identifier.');\n  warning(\n    identifier <= MAX_TOUCH_BANK,\n    'Touch identifier %s is greater than maximum supported %s which causes ' +\n      'performance issues backfilling array locations for all of the indices.',\n    identifier,\n    MAX_TOUCH_BANK,\n  );\n  return identifier;\n}\n\nfunction recordTouchStart(touch: Touch): void {\n  const identifier = getTouchIdentifier(touch);\n  const touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch: Touch): void {\n  const touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      'Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n',\n      'Touch Bank: %s',\n      printTouch(touch),\n      printTouchBank(),\n    );\n  }\n}\n\nfunction recordTouchEnd(touch: Touch): void {\n  const touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      'Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n',\n      'Touch Bank: %s',\n      printTouch(touch),\n      printTouchBank(),\n    );\n  }\n}\n\nfunction printTouch(touch: Touch): string {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch),\n  });\n}\n\nfunction printTouchBank(): string {\n  let printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\n\nconst ResponderTouchHistoryStore = {\n  recordTouchTrack(topLevelType: string, nativeEvent: TouchEvent): void {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[\n          0\n        ].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (let i = 0; i < touchBank.length; i++) {\n          const touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        if (__DEV__) {\n          const activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          warning(\n            activeRecord != null && activeRecord.touchActive,\n            'Cannot find single active touch.',\n          );\n        }\n      }\n    }\n  },\n\n  touchHistory,\n};\n\nmodule.exports = ResponderTouchHistoryStore;\n"]}]