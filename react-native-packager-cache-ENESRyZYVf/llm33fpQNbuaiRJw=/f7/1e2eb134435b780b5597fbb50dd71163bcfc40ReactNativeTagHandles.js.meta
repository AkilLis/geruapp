["9e2bb551b820608f2a5f8d2db73f246e4093953d","48c351e7db14021fbacf88a8d2b6ff3043bf5fa5",["fbjs/lib/invariant"],[40],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/native/ReactNativeTagHandles.js"],"names":["invariant","require","INITIAL_TAG_COUNT","ReactNativeTagHandles","tagsStartAt","tagCount","allocateTag","reactTagIsNativeTopRootID","tag","assertRootTag","reactTag","module","exports"],"mappings":";AAWA;;AAEA,IAAIA,YAAYC,QAAQ,oBAAR,CAAhB;;AAeA,IAAIC,oBAAoB,CAAxB;AACA,IAAIC,wBAAwB;AAC1BC,eAAaF,iBADa;AAE1BG,YAAUH,iBAFgB;;AAI1BI,eAAa,uBAAmB;AAE9B,WAAO,KAAKC,yBAAL,CAA+BJ,sBAAsBE,QAArD,CAAP,EAAuE;AACrEF,4BAAsBE,QAAtB;AACD;AACD,QAAIG,MAAML,sBAAsBE,QAAhC;AACAF,0BAAsBE,QAAtB;AACA,WAAOG,GAAP;AACD,GAZyB;;AAc1BC,iBAAe,uBAASD,GAAT,EAA4B;AACzCR,cACE,KAAKO,yBAAL,CAA+BC,GAA/B,CADF,EAEE,0CAFF,EAGEA,GAHF;AAKD,GApByB;;AAsB1BD,6BAA2B,mCAASG,QAAT,EAAoC;AAE7D,WAAOA,WAAW,EAAX,KAAkB,CAAzB;AACD;AAzByB,CAA5B;;AA4BAC,OAAOC,OAAP,GAAiBT,qBAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNativeTagHandles\n * @flow\n */\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Keeps track of allocating and associating native \"tags\" which are numeric,\n * unique view IDs. All the native tags are negative numbers, to avoid\n * collisions, but in the JS we keep track of them as positive integers to store\n * them effectively in Arrays. So we must refer to them as \"inverses\" of the\n * native tags (that are * normally negative).\n *\n * It *must* be the case that every `rootNodeID` always maps to the exact same\n * `tag` forever. The easiest way to accomplish this is to never delete\n * anything from this table.\n * Why: Because `dangerouslyReplaceNodeWithMarkupByID` relies on being able to\n * unmount a component with a `rootNodeID`, then mount a new one in its place,\n */\nvar INITIAL_TAG_COUNT = 1;\nvar ReactNativeTagHandles = {\n  tagsStartAt: INITIAL_TAG_COUNT,\n  tagCount: INITIAL_TAG_COUNT,\n\n  allocateTag: function(): number {\n    // Skip over root IDs as those are reserved for native\n    while (this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) {\n      ReactNativeTagHandles.tagCount++;\n    }\n    var tag = ReactNativeTagHandles.tagCount;\n    ReactNativeTagHandles.tagCount++;\n    return tag;\n  },\n\n  assertRootTag: function(tag: number): void {\n    invariant(\n      this.reactTagIsNativeTopRootID(tag),\n      'Expect a native root tag, instead got %s',\n      tag,\n    );\n  },\n\n  reactTagIsNativeTopRootID: function(reactTag: number): boolean {\n    // We reserve all tags that are 1 mod 10 for native root views\n    return reactTag % 10 === 1;\n  },\n};\n\nmodule.exports = ReactNativeTagHandles;\n"]}]