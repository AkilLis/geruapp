["69c26699310053f9421400c1d43814e63dcc421b","3e615b7494c928116a3f929c495d2bafef9d88f2",["fbjs/lib/emptyObject","getComponentName","fbjs/lib/invariant","fbjs/lib/warning","ReactFiberTreeReflection","ReactTypeOfWork","ReactFiberStack","checkReactTypeSpec","react/lib/ReactDebugCurrentFrame","ReactDebugCurrentFiber","ReactDebugFiberPerf"],[43,99,144,189,234,334,461,627,689,765,819],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberContext.js"],"names":["emptyObject","require","getComponentName","invariant","warning","isFiberMounted","ClassComponent","HostRoot","createCursor","pop","push","__DEV__","checkReactTypeSpec","ReactDebugCurrentFrame","ReactDebugCurrentFiber","startPhaseTimer","stopPhaseTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","workInProgress","hasOwnContext","isContextProvider","current","exports","cacheContext","unmaskedContext","maskedContext","instance","stateNode","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","type","contextTypes","context","key","name","hasContextChanged","isContextConsumer","fiber","tag","childContextTypes","popContextProvider","pushTopLevelContextObject","didChange","cursor","processChildContext","parentContext","isReconciling","getChildContext","componentName","childContext","phase","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","node","parent","return"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberContext\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\nimport type {StackCursor} from 'ReactFiberStack';\n\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar getComponentName = require('getComponentName');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar {\n  isFiberMounted,\n} = require('ReactFiberTreeReflection');\nvar {\n  ClassComponent,\n  HostRoot,\n} = require('ReactTypeOfWork');\nconst {\n  createCursor,\n  pop,\n  push,\n} = require('ReactFiberStack');\n\nif (__DEV__) {\n  var checkReactTypeSpec = require('checkReactTypeSpec');\n  var ReactDebugCurrentFrame = require('react/lib/ReactDebugCurrentFrame');\n  var ReactDebugCurrentFiber = require('ReactDebugCurrentFiber');\n  var {\n    startPhaseTimer,\n    stopPhaseTimer,\n  } = require('ReactDebugFiberPerf');\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nlet contextStackCursor: StackCursor<Object> = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nlet didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nlet previousContext: Object = emptyObject;\n\nfunction getUnmaskedContext(workInProgress: Fiber): Object {\n  const hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\nexports.getUnmaskedContext = getUnmaskedContext;\n\nfunction cacheContext(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n  maskedContext: Object,\n) {\n  const instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\nexports.cacheContext = cacheContext;\n\nexports.getMaskedContext = function(\n  workInProgress: Fiber,\n  unmaskedContext: Object,\n) {\n  const type = workInProgress.type;\n  const contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  const instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  const context = {};\n  for (let key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  if (__DEV__) {\n    const name = getComponentName(workInProgress) || 'Unknown';\n    ReactDebugCurrentFrame.current = workInProgress;\n    checkReactTypeSpec(contextTypes, context, 'context', name);\n    ReactDebugCurrentFrame.current = null;\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n};\n\nexports.hasContextChanged = function(): boolean {\n  return didPerformWorkStackCursor.current;\n};\n\nfunction isContextConsumer(fiber: Fiber): boolean {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\nexports.isContextConsumer = isContextConsumer;\n\nfunction isContextProvider(fiber: Fiber): boolean {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\nexports.isContextProvider = isContextProvider;\n\nfunction popContextProvider(fiber: Fiber): void {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\nexports.popContextProvider = popContextProvider;\n\nexports.pushTopLevelContextObject = function(\n  fiber: Fiber,\n  context: Object,\n  didChange: boolean,\n): void {\n  invariant(\n    contextStackCursor.cursor == null,\n    'Unexpected context found on stack',\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n};\n\nfunction processChildContext(\n  fiber: Fiber,\n  parentContext: Object,\n  isReconciling: boolean,\n): Object {\n  const instance = fiber.stateNode;\n  const childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    if (__DEV__) {\n      const componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(\n          false,\n          '%s.childContextTypes is specified but there is no getChildContext() method ' +\n            'on the instance. You can either define getChildContext() on %s or remove ' +\n            'childContextTypes from it.',\n          componentName,\n          componentName,\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  let childContext;\n  if (__DEV__) {\n    ReactDebugCurrentFiber.phase = 'getChildContext';\n    startPhaseTimer(fiber, 'getChildContext');\n    childContext = instance.getChildContext();\n    stopPhaseTimer();\n    ReactDebugCurrentFiber.phase = null;\n  } else {\n    childContext = instance.getChildContext();\n  }\n  for (let contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(fiber) || 'Unknown',\n      contextKey,\n    );\n  }\n  if (__DEV__) {\n    const name = getComponentName(fiber) || 'Unknown';\n    // We can only provide accurate element stacks if we pass work-in-progress tree\n    // during the begin or complete phase. However currently this function is also\n    // called from unstable_renderSubtree legacy implementation. In this case it unsafe to\n    // assume anything about the given fiber. We won't pass it down if we aren't sure.\n    // TODO: remove this hack when we delete unstable_renderSubtree in Fiber.\n    const workInProgress = isReconciling ? fiber : null;\n    ReactDebugCurrentFrame.current = workInProgress;\n    checkReactTypeSpec(childContextTypes, childContext, 'child context', name);\n    ReactDebugCurrentFrame.current = null;\n  }\n\n  return {...parentContext, ...childContext};\n}\nexports.processChildContext = processChildContext;\n\nexports.pushContextProvider = function(workInProgress: Fiber): boolean {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  const instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  const memoizedMergedChildContext = (instance &&\n    instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, false, workInProgress);\n\n  return true;\n};\n\nexports.invalidateContextProvider = function(workInProgress: Fiber): void {\n  const instance = workInProgress.stateNode;\n  invariant(instance, 'Expected to have an instance by this point.');\n\n  // Merge parent and own context.\n  const mergedContext = processChildContext(\n    workInProgress,\n    previousContext,\n    true,\n  );\n  instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n  // Replace the old (or empty) context with the new one.\n  // It is important to unwind the context in the reverse order.\n  pop(didPerformWorkStackCursor, workInProgress);\n  pop(contextStackCursor, workInProgress);\n  // Now push the new context and mark that it has changed.\n  push(contextStackCursor, mergedContext, workInProgress);\n  push(didPerformWorkStackCursor, true, workInProgress);\n};\n\nexports.resetContext = function(): void {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n};\n\nexports.findCurrentUnmaskedContext = function(fiber: Fiber): Object {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) && fiber.tag === ClassComponent,\n    'Expected subtree parent to be a mounted class component',\n  );\n\n  let node: Fiber = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    const parent = node.return;\n    invariant(parent, 'Found unexpected detached subtree parent');\n    node = parent;\n  }\n  return node.stateNode.context;\n};\n"]}]