["35de9831a0c14f547273f25f68b4386416f7f824","1308aa7e82b291db513bfd78e18ca69f6e492b82",["ReactInstanceMap","react/lib/ReactCurrentOwner","getComponentName","fbjs/lib/invariant","fbjs/lib/warning","ReactTypeOfWork","ReactTypeOfSideEffect"],[48,101,165,210,273,320,523],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberTreeReflection.js"],"names":["ReactInstanceMap","require","ReactCurrentOwner","getComponentName","invariant","__DEV__","warning","HostRoot","HostComponent","HostText","ClassComponent","NoEffect","Placement","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","fiber","node","alternate","effectTag","return","tag","exports","isFiberMounted","isMounted","component","owner","current","ownerFiber","instance","stateNode","_warnedAboutRefsInRender","get","assertIsMounted","findCurrentFiberUsingSlowPath","state","a","b","parentA","parentB","child","sibling","didFindChild","findCurrentHostFiber","parent","currentParent"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberTreeReflection\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\n\nvar ReactInstanceMap = require('ReactInstanceMap');\nvar ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\n\nvar getComponentName = require('getComponentName');\nvar invariant = require('fbjs/lib/invariant');\n\nif (__DEV__) {\n  var warning = require('fbjs/lib/warning');\n}\n\nvar {\n  HostRoot,\n  HostComponent,\n  HostText,\n  ClassComponent,\n} = require('ReactTypeOfWork');\n\nvar {\n  NoEffect,\n  Placement,\n} = require('ReactTypeOfSideEffect');\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber: Fiber): number {\n  let node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\nexports.isFiberMounted = function(fiber: Fiber): boolean {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n};\n\nexports.isMounted = function(\n  component: ReactComponent<any, any, any>,\n): boolean {\n  if (__DEV__) {\n    const owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.tag === ClassComponent) {\n      const ownerFiber: Fiber = owner;\n      const instance = ownerFiber.stateNode;\n      warning(\n        instance._warnedAboutRefsInRender,\n        '%s is accessing isMounted inside its render() function. ' +\n          'render() should be a pure function of props and state. It should ' +\n          'never access something that requires stale data from the previous ' +\n          'render, such as refs. Move this logic to componentDidMount and ' +\n          'componentDidUpdate instead.',\n        getComponentName(ownerFiber) || 'A component',\n      );\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber: ?Fiber = ReactInstanceMap.get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n};\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    'Unable to find node on an unmounted component.',\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber | null {\n  let alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      'Unable to find node on an unmounted component.',\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a = fiber;\n  let b = alternate;\n  while (true) {\n    let parentA = a.return;\n    let parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers pointer to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n        invariant(\n          didFindChild,\n          'Child was not found in either parent set. This indicates a bug ' +\n            'related to the return pointer.',\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates.\",\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    'Unable to find node on an unmounted component.',\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\nexports.findCurrentFiberUsingSlowPath = findCurrentFiberUsingSlowPath;\n\nexports.findCurrentHostFiber = function(parent: Fiber): Fiber | null {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  let node: Fiber = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      // TODO: If we hit a Portal, we're supposed to skip it.\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n};\n"]}]