["5971ae0046b2e8ee87a6023d8f3736c2ce604812","12b6f69a00274076386a88a5d852222b3f93bc6b",["ReactTypeOfSideEffect","ReactPriorityLevel","fbjs/lib/invariant","fbjs/lib/warning"],[40,131,310,372],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiberUpdateQueue.js"],"names":["require","CallbackEffect","Callback","NoWork","SynchronousPriority","TaskPriority","invariant","__DEV__","warning","comparePriority","a","b","ensureUpdateQueue","fiber","updateQueue","queue","first","last","hasForceUpdate","callbackList","isProcessing","cloneUpdateQueue","current","workInProgress","currentQueue","altQueue","exports","cloneUpdate","update","priorityLevel","partialState","callback","isReplace","isForced","isTopLevelUnmount","next","insertUpdateIntoQueue","insertAfter","insertBefore","findInsertionPosition","insertUpdate","queue1","queue2","alternate","insertAfter1","insertBefore1","insertAfter2","insertBefore2","update2","addUpdate","addReplaceUpdate","state","addForceUpdate","getPendingPriority","addTopLevelUpdate","element","getStateFromUpdate","instance","prevState","props","updateFn","call","beginUpdateQueue","dontMutatePrevState","push","effectTag","commitCallbacks","finishedWork","context","i","length"],"mappings":";;AAYA;;eAOIA,QAAQ,uBAAR,C;IADQC,c,YAAVC,Q;;gBAOEF,QAAQ,oBAAR,C;IAHFG,M,aAAAA,M;IACAC,mB,aAAAA,mB;IACAC,Y,aAAAA,Y;;AAGF,IAAMC,YAAYN,QAAQ,oBAAR,CAAlB;AACA,IAAIO,OAAJ,EAAa;AACX,MAAIC,UAAUR,QAAQ,kBAAR,CAAd;AACD;;AAwCD,SAASS,eAAT,CAAyBC,CAAzB,EAA2CC,CAA3C,EAAqE;AAInE,MACE,CAACD,MAAML,YAAN,IAAsBK,MAAMN,mBAA7B,MACCO,MAAMN,YAAN,IAAsBM,MAAMP,mBAD7B,CADF,EAGE;AACA,WAAO,CAAP;AACD;AACD,MAAIM,MAAMP,MAAN,IAAgBQ,MAAMR,MAA1B,EAAkC;AAChC,WAAO,CAAC,GAAR;AACD;AACD,MAAIO,MAAMP,MAAN,IAAgBQ,MAAMR,MAA1B,EAAkC;AAChC,WAAO,GAAP;AACD;AACD,SAAOO,IAAIC,CAAX;AACD;;AAID,SAASC,iBAAT,CAA2BC,KAA3B,EAAsD;AACpD,MAAIA,MAAMC,WAAN,KAAsB,IAA1B,EAAgC;AAE9B,WAAOD,MAAMC,WAAb;AACD;;AAED,MAAIC,cAAJ;AACA,MAAIR,OAAJ,EAAa;AACXQ,YAAQ;AACNC,aAAO,IADD;AAENC,YAAM,IAFA;AAGNC,sBAAgB,KAHV;AAINC,oBAAc,IAJR;AAKNC,oBAAc;AALR,KAAR;AAOD,GARD,MAQO;AACLL,YAAQ;AACNC,aAAO,IADD;AAENC,YAAM,IAFA;AAGNC,sBAAgB,KAHV;AAINC,oBAAc;AAJR,KAAR;AAMD;;AAEDN,QAAMC,WAAN,GAAoBC,KAApB;AACA,SAAOA,KAAP;AACD;;AAGD,SAASM,gBAAT,CACEC,OADF,EAEEC,cAFF,EAGsB;AACpB,MAAMC,eAAeF,QAAQR,WAA7B;AACA,MAAIU,iBAAiB,IAArB,EAA2B;AAEzBD,mBAAeT,WAAf,GAA6B,IAA7B;AACA,WAAO,IAAP;AACD;;AAED,MAAMW,WAAWF,eAAeT,WAAf,KAA+B,IAA/B,GACbS,eAAeT,WADF,GAEb,EAFJ;AAGAW,WAAST,KAAT,GAAiBQ,aAAaR,KAA9B;AACAS,WAASR,IAAT,GAAgBO,aAAaP,IAA7B;;AAGAQ,WAASP,cAAT,GAA0B,KAA1B;AACAO,WAASN,YAAT,GAAwB,IAAxB;AACAM,WAASL,YAAT,GAAwB,KAAxB;;AAEAG,iBAAeT,WAAf,GAA6BW,QAA7B;;AAEA,SAAOA,QAAP;AACD;AACDC,QAAQL,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASM,WAAT,CAAqBC,MAArB,EAA6C;AAC3C,SAAO;AACLC,mBAAeD,OAAOC,aADjB;AAELC,kBAAcF,OAAOE,YAFhB;AAGLC,cAAUH,OAAOG,QAHZ;AAILC,eAAWJ,OAAOI,SAJb;AAKLC,cAAUL,OAAOK,QALZ;AAMLC,uBAAmBN,OAAOM,iBANrB;AAOLC,UAAM;AAPD,GAAP;AASD;;AAED,SAASC,qBAAT,CACErB,KADF,EAEEa,MAFF,EAGES,WAHF,EAIEC,YAJF,EAKE;AACA,MAAID,gBAAgB,IAApB,EAA0B;AACxBA,gBAAYF,IAAZ,GAAmBP,MAAnB;AACD,GAFD,MAEO;AAELA,WAAOO,IAAP,GAAcpB,MAAMC,KAApB;AACAD,UAAMC,KAAN,GAAcY,MAAd;AACD;;AAED,MAAIU,iBAAiB,IAArB,EAA2B;AACzBV,WAAOO,IAAP,GAAcG,YAAd;AACD,GAFD,MAEO;AAELvB,UAAME,IAAN,GAAaW,MAAb;AACD;AACF;;AAID,SAASW,qBAAT,CAA+BxB,KAA/B,EAAsCa,MAAtC,EAA6D;AAC3D,MAAMC,gBAAgBD,OAAOC,aAA7B;AACA,MAAIQ,cAAc,IAAlB;AACA,MAAIC,eAAe,IAAnB;AACA,MACEvB,MAAME,IAAN,KAAe,IAAf,IACAR,gBAAgBM,MAAME,IAAN,CAAWY,aAA3B,EAA0CA,aAA1C,KAA4D,CAF9D,EAGE;AAGAQ,kBAActB,MAAME,IAApB;AACD,GAPD,MAOO;AACLqB,mBAAevB,MAAMC,KAArB;AACA,WACEsB,iBAAiB,IAAjB,IACA7B,gBAAgB6B,aAAaT,aAA7B,EAA4CA,aAA5C,KAA8D,CAFhE,EAGE;AACAQ,oBAAcC,YAAd;AACAA,qBAAeA,aAAaH,IAA5B;AACD;AACF;AACD,SAAOE,WAAP;AACD;;AA+BD,SAASG,YAAT,CAAsB3B,KAAtB,EAAoCe,MAApC,EAAmE;AACjE,MAAMa,SAAS7B,kBAAkBC,KAAlB,CAAf;AACA,MAAM6B,SAAS7B,MAAM8B,SAAN,KAAoB,IAApB,GACX/B,kBAAkBC,MAAM8B,SAAxB,CADW,GAEX,IAFJ;;AAKA,MAAIpC,OAAJ,EAAa;AACX,QAAIkC,OAAOrB,YAAP,IAAwBsB,WAAW,IAAX,IAAmBA,OAAOtB,YAAtD,EAAqE;AACnEZ,cACE,KADF,EAEE,sEACE,mEADF,GAEE,iEAFF,GAGE,WALJ;AAOD;AACF;;AAGD,MAAMoC,eAAeL,sBAAsBE,MAAtB,EAA8Bb,MAA9B,CAArB;AACA,MAAMiB,gBAAgBD,iBAAiB,IAAjB,GAClBA,aAAaT,IADK,GAElBM,OAAOzB,KAFX;;AAIA,MAAI0B,WAAW,IAAf,EAAqB;AAEnBN,0BAAsBK,MAAtB,EAA8Bb,MAA9B,EAAsCgB,YAAtC,EAAoDC,aAApD;AACA,WAAO,IAAP;AACD;;AAGD,MAAMC,eAAeP,sBAAsBG,MAAtB,EAA8Bd,MAA9B,CAArB;AACA,MAAMmB,gBAAgBD,iBAAiB,IAAjB,GAClBA,aAAaX,IADK,GAElBO,OAAO1B,KAFX;;AAMAoB,wBAAsBK,MAAtB,EAA8Bb,MAA9B,EAAsCgB,YAAtC,EAAoDC,aAApD;;AAEA,MAAIA,kBAAkBE,aAAtB,EAAqC;AAGnC,QAAMC,UAAUrB,YAAYC,MAAZ,CAAhB;AACAQ,0BAAsBM,MAAtB,EAA8BM,OAA9B,EAAuCF,YAAvC,EAAqDC,aAArD;AACA,WAAOC,OAAP;AACD,GAND,MAMO;AAKL,QAAIF,iBAAiB,IAArB,EAA2B;AACzBJ,aAAO1B,KAAP,GAAeY,MAAf;AACD;AACD,QAAImB,kBAAkB,IAAtB,EAA4B;AAC1BL,aAAOzB,IAAP,GAAc,IAAd;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,SAASgC,SAAT,CACEpC,KADF,EAEEiB,YAFF,EAGEC,QAHF,EAIEF,aAJF,EAKQ;AACN,MAAMD,SAAS;AACbC,gCADa;AAEbC,8BAFa;AAGbC,sBAHa;AAIbC,eAAW,KAJE;AAKbC,cAAU,KALG;AAMbC,uBAAmB,KANN;AAObC,UAAM;AAPO,GAAf;AASAK,eAAa3B,KAAb,EAAoBe,MAApB;AACD;AACDF,QAAQuB,SAAR,GAAoBA,SAApB;;AAEA,SAASC,gBAAT,CACErC,KADF,EAEEsC,KAFF,EAGEpB,QAHF,EAIEF,aAJF,EAKQ;AACN,MAAMD,SAAS;AACbC,gCADa;AAEbC,kBAAcqB,KAFD;AAGbpB,sBAHa;AAIbC,eAAW,IAJE;AAKbC,cAAU,KALG;AAMbC,uBAAmB,KANN;AAObC,UAAM;AAPO,GAAf;AASAK,eAAa3B,KAAb,EAAoBe,MAApB;AACD;AACDF,QAAQwB,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASE,cAAT,CACEvC,KADF,EAEEkB,QAFF,EAGEF,aAHF,EAIQ;AACN,MAAMD,SAAS;AACbC,gCADa;AAEbC,kBAAc,IAFD;AAGbC,sBAHa;AAIbC,eAAW,KAJE;AAKbC,cAAU,IALG;AAMbC,uBAAmB,KANN;AAObC,UAAM;AAPO,GAAf;AASAK,eAAa3B,KAAb,EAAoBe,MAApB;AACD;AACDF,QAAQ0B,cAAR,GAAyBA,cAAzB;;AAEA,SAASC,kBAAT,CAA4BtC,KAA5B,EAA+D;AAC7D,SAAOA,MAAMC,KAAN,KAAgB,IAAhB,GAAuBD,MAAMC,KAAN,CAAYa,aAAnC,GAAmD1B,MAA1D;AACD;AACDuB,QAAQ2B,kBAAR,GAA6BA,kBAA7B;;AAEA,SAASC,iBAAT,CACEzC,KADF,EAEEiB,YAFF,EAGEC,QAHF,EAIEF,aAJF,EAKQ;AACN,MAAMK,oBAAoBJ,aAAayB,OAAb,KAAyB,IAAnD;;AAEA,MAAM3B,SAAS;AACbC,gCADa;AAEbC,8BAFa;AAGbC,sBAHa;AAIbC,eAAW,KAJE;AAKbC,cAAU,KALG;AAMbC,wCANa;AAObC,UAAM;AAPO,GAAf;AASA,MAAMa,UAAUR,aAAa3B,KAAb,EAAoBe,MAApB,CAAhB;;AAEA,MAAIM,iBAAJ,EAAuB;AAGrB,QAAMO,SAAS5B,MAAMC,WAArB;AACA,QAAM4B,SAAS7B,MAAM8B,SAAN,KAAoB,IAApB,GACX9B,MAAM8B,SAAN,CAAgB7B,WADL,GAEX,IAFJ;;AAIA,QAAI2B,WAAW,IAAX,IAAmBb,OAAOO,IAAP,KAAgB,IAAvC,EAA6C;AAC3CP,aAAOO,IAAP,GAAc,IAAd;AACAM,aAAOxB,IAAP,GAAcW,MAAd;AACD;AACD,QAAIc,WAAW,IAAX,IAAmBM,YAAY,IAA/B,IAAuCA,QAAQb,IAAR,KAAiB,IAA5D,EAAkE;AAChEa,cAAQb,IAAR,GAAe,IAAf;AACAO,aAAOzB,IAAP,GAAcW,MAAd;AACD;AACF;AACF;AACDF,QAAQ4B,iBAAR,GAA4BA,iBAA5B;;AAEA,SAASE,kBAAT,CAA4B5B,MAA5B,EAAoC6B,QAApC,EAA8CC,SAA9C,EAAyDC,KAAzD,EAAgE;AAC9D,MAAM7B,eAAeF,OAAOE,YAA5B;AACA,MAAI,OAAOA,YAAP,KAAwB,UAA5B,EAAwC;AACtC,QAAM8B,WAAW9B,YAAjB;AACA,WAAO8B,SAASC,IAAT,CAAcJ,QAAd,EAAwBC,SAAxB,EAAmCC,KAAnC,CAAP;AACD,GAHD,MAGO;AACL,WAAO7B,YAAP;AACD;AACF;;AAED,SAASgC,gBAAT,CACEvC,cADF,EAEER,KAFF,EAGE0C,QAHF,EAIEC,SAJF,EAKEC,KALF,EAME9B,aANF,EAOO;AACL,MAAItB,OAAJ,EAAa;AAGXQ,UAAMK,YAAN,GAAqB,IAArB;AACD;;AAEDL,QAAMG,cAAN,GAAuB,KAAvB;;AAIA,MAAIiC,QAAQO,SAAZ;AACA,MAAIK,sBAAsB,IAA1B;AACA,MAAI5C,eAAe,IAAnB;AACA,MAAIS,SAASb,MAAMC,KAAnB;AACA,SACEY,WAAW,IAAX,IAAmBnB,gBAAgBmB,OAAOC,aAAvB,EAAsCA,aAAtC,KAAwD,CAD7E,EAEE;AAIAd,UAAMC,KAAN,GAAcY,OAAOO,IAArB;AACA,QAAIpB,MAAMC,KAAN,KAAgB,IAApB,EAA0B;AACxBD,YAAME,IAAN,GAAa,IAAb;AACD;;AAED,QAAIa,sBAAJ;AACA,QAAIF,OAAOI,SAAX,EAAsB;AACpBmB,cAAQK,mBAAmB5B,MAAnB,EAA2B6B,QAA3B,EAAqCN,KAArC,EAA4CQ,KAA5C,CAAR;AACAI,4BAAsB,IAAtB;AACD,KAHD,MAGO;AACLjC,sBAAe0B,mBAAmB5B,MAAnB,EAA2B6B,QAA3B,EAAqCN,KAArC,EAA4CQ,KAA5C,CAAf;AACA,UAAI7B,aAAJ,EAAkB;AAChB,YAAIiC,mBAAJ,EAAyB;AACvBZ,kBAAQ,qBAAc,EAAd,EAAkBA,KAAlB,EAAyBrB,aAAzB,CAAR;AACD,SAFD,MAEO;AACLqB,kBAAQ,qBAAcA,KAAd,EAAqBrB,aAArB,CAAR;AACD;AACDiC,8BAAsB,KAAtB;AACD;AACF;AACD,QAAInC,OAAOK,QAAX,EAAqB;AACnBlB,YAAMG,cAAN,GAAuB,IAAvB;AACD;;AAGD,QACEU,OAAOG,QAAP,KAAoB,IAApB,IACA,EAAEH,OAAOM,iBAAP,IAA4BN,OAAOO,IAAP,KAAgB,IAA9C,CAFF,EAGE;AACAhB,qBAAeA,gBAAgB,EAA/B;AACAA,mBAAa6C,IAAb,CAAkBpC,OAAOG,QAAzB;AACAR,qBAAe0C,SAAf,IAA4BhE,cAA5B;AACD;AACD2B,aAASA,OAAOO,IAAhB;AACD;;AAEDpB,QAAMI,YAAN,GAAqBA,YAArB;;AAEA,MAAIJ,MAAMC,KAAN,KAAgB,IAAhB,IAAwBG,iBAAiB,IAAzC,IAAiD,CAACJ,MAAMG,cAA5D,EAA4E;AAE1EK,mBAAeT,WAAf,GAA6B,IAA7B;AACD;;AAED,MAAIP,OAAJ,EAAa;AACXQ,UAAMK,YAAN,GAAqB,KAArB;AACD;;AAED,SAAO+B,KAAP;AACD;AACDzB,QAAQoC,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASI,eAAT,CACEC,YADF,EAEEpD,KAFF,EAGEqD,OAHF,EAIE;AACA,MAAMjD,eAAeJ,MAAMI,YAA3B;AACA,MAAIA,iBAAiB,IAArB,EAA2B;AACzB;AACD;AACD,OAAK,IAAIkD,IAAI,CAAb,EAAgBA,IAAIlD,aAAamD,MAAjC,EAAyCD,GAAzC,EAA8C;AAC5C,QAAMtC,YAAWZ,aAAakD,CAAb,CAAjB;AACA/D,cACE,OAAOyB,SAAP,KAAoB,UADtB,EAEE,uEACE,cAHJ,EAIEA,SAJF;AAMAA,cAAS8B,IAAT,CAAcO,OAAd;AACD;AACF;AACD1C,QAAQwC,eAAR,GAA0BA,eAA1B","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiberUpdateQueue\n * @flow\n */\n\n'use strict';\n\nimport type {Fiber} from 'ReactFiber';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\n\nconst {\n  Callback: CallbackEffect,\n} = require('ReactTypeOfSideEffect');\n\nconst {\n  NoWork,\n  SynchronousPriority,\n  TaskPriority,\n} = require('ReactPriorityLevel');\n\nconst invariant = require('fbjs/lib/invariant');\nif (__DEV__) {\n  var warning = require('fbjs/lib/warning');\n}\n\ntype PartialState<State, Props> =\n  | $Subtype<State>\n  | ((prevState: State, props: Props) => $Subtype<State>);\n\n// Callbacks are not validated until invocation\ntype Callback = mixed;\n\ntype Update = {\n  priorityLevel: PriorityLevel,\n  partialState: PartialState<any, any>,\n  callback: Callback | null,\n  isReplace: boolean,\n  isForced: boolean,\n  isTopLevelUnmount: boolean,\n  next: Update | null,\n};\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\nexport type UpdateQueue = {\n  first: Update | null,\n  last: Update | null,\n  hasForceUpdate: boolean,\n  callbackList: null | Array<Callback>,\n\n  // Dev only\n  isProcessing?: boolean,\n};\n\nfunction comparePriority(a: PriorityLevel, b: PriorityLevel): number {\n  // When comparing update priorities, treat sync and Task work as equal.\n  // TODO: Could we avoid the need for this by always coercing sync priority\n  // to Task when scheduling an update?\n  if (\n    (a === TaskPriority || a === SynchronousPriority) &&\n    (b === TaskPriority || b === SynchronousPriority)\n  ) {\n    return 0;\n  }\n  if (a === NoWork && b !== NoWork) {\n    return -255;\n  }\n  if (a !== NoWork && b === NoWork) {\n    return 255;\n  }\n  return a - b;\n}\n\n// Ensures that a fiber has an update queue, creating a new one if needed.\n// Returns the new or existing queue.\nfunction ensureUpdateQueue(fiber: Fiber): UpdateQueue {\n  if (fiber.updateQueue !== null) {\n    // We already have an update queue.\n    return fiber.updateQueue;\n  }\n\n  let queue;\n  if (__DEV__) {\n    queue = {\n      first: null,\n      last: null,\n      hasForceUpdate: false,\n      callbackList: null,\n      isProcessing: false,\n    };\n  } else {\n    queue = {\n      first: null,\n      last: null,\n      hasForceUpdate: false,\n      callbackList: null,\n    };\n  }\n\n  fiber.updateQueue = queue;\n  return queue;\n}\n\n// Clones an update queue from a source fiber onto its alternate.\nfunction cloneUpdateQueue(\n  current: Fiber,\n  workInProgress: Fiber,\n): UpdateQueue | null {\n  const currentQueue = current.updateQueue;\n  if (currentQueue === null) {\n    // The source fiber does not have an update queue.\n    workInProgress.updateQueue = null;\n    return null;\n  }\n  // If the alternate already has a queue, reuse the previous object.\n  const altQueue = workInProgress.updateQueue !== null\n    ? workInProgress.updateQueue\n    : {};\n  altQueue.first = currentQueue.first;\n  altQueue.last = currentQueue.last;\n\n  // These fields are invalid by the time we clone from current. Reset them.\n  altQueue.hasForceUpdate = false;\n  altQueue.callbackList = null;\n  altQueue.isProcessing = false;\n\n  workInProgress.updateQueue = altQueue;\n\n  return altQueue;\n}\nexports.cloneUpdateQueue = cloneUpdateQueue;\n\nfunction cloneUpdate(update: Update): Update {\n  return {\n    priorityLevel: update.priorityLevel,\n    partialState: update.partialState,\n    callback: update.callback,\n    isReplace: update.isReplace,\n    isForced: update.isForced,\n    isTopLevelUnmount: update.isTopLevelUnmount,\n    next: null,\n  };\n}\n\nfunction insertUpdateIntoQueue(\n  queue: UpdateQueue,\n  update: Update,\n  insertAfter: Update | null,\n  insertBefore: Update | null,\n) {\n  if (insertAfter !== null) {\n    insertAfter.next = update;\n  } else {\n    // This is the first item in the queue.\n    update.next = queue.first;\n    queue.first = update;\n  }\n\n  if (insertBefore !== null) {\n    update.next = insertBefore;\n  } else {\n    // This is the last item in the queue.\n    queue.last = update;\n  }\n}\n\n// Returns the update after which the incoming update should be inserted into\n// the queue, or null if it should be inserted at beginning.\nfunction findInsertionPosition(queue, update): Update | null {\n  const priorityLevel = update.priorityLevel;\n  let insertAfter = null;\n  let insertBefore = null;\n  if (\n    queue.last !== null &&\n    comparePriority(queue.last.priorityLevel, priorityLevel) <= 0\n  ) {\n    // Fast path for the common case where the update should be inserted at\n    // the end of the queue.\n    insertAfter = queue.last;\n  } else {\n    insertBefore = queue.first;\n    while (\n      insertBefore !== null &&\n      comparePriority(insertBefore.priorityLevel, priorityLevel) <= 0\n    ) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore.next;\n    }\n  }\n  return insertAfter;\n}\n\n// The work-in-progress queue is a subset of the current queue (if it exists).\n// We need to insert the incoming update into both lists. However, it's possible\n// that the correct position in one list will be different from the position in\n// the other. Consider the following case:\n//\n//     Current:             3-5-6\n//     Work-in-progress:        6\n//\n// Then we receive an update with priority 4 and insert it into each list:\n//\n//     Current:             3-4-5-6\n//     Work-in-progress:        4-6\n//\n// In the current queue, the new update's `next` pointer points to the update\n// with priority 5. But in the work-in-progress queue, the pointer points to the\n// update with priority 6. Because these two queues share the same persistent\n// data structure, this won't do. (This can only happen when the incoming update\n// has higher priority than all the updates in the work-in-progress queue.)\n//\n// To solve this, in the case where the incoming update needs to be inserted\n// into two different positions, we'll make a clone of the update and insert\n// each copy into a separate queue. This forks the list while maintaining a\n// persistent structure, because the update that is added to the work-in-progress\n// is always added to the front of the list.\n//\n// However, if incoming update is inserted into the same position of both lists,\n// we shouldn't make a copy.\n//\n// If the update is cloned, it returns the cloned update.\nfunction insertUpdate(fiber: Fiber, update: Update): Update | null {\n  const queue1 = ensureUpdateQueue(fiber);\n  const queue2 = fiber.alternate !== null\n    ? ensureUpdateQueue(fiber.alternate)\n    : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  if (__DEV__) {\n    if (queue1.isProcessing || (queue2 !== null && queue2.isProcessing)) {\n      warning(\n        false,\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n    }\n  }\n\n  // Find the insertion position in the first queue.\n  const insertAfter1 = findInsertionPosition(queue1, update);\n  const insertBefore1 = insertAfter1 !== null\n    ? insertAfter1.next\n    : queue1.first;\n\n  if (queue2 === null) {\n    // If there's no alternate queue, there's nothing else to do but insert.\n    insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1);\n    return null;\n  }\n\n  // If there is an alternate queue, find the insertion position.\n  const insertAfter2 = findInsertionPosition(queue2, update);\n  const insertBefore2 = insertAfter2 !== null\n    ? insertAfter2.next\n    : queue2.first;\n\n  // Now we can insert into the first queue. This must come after finding both\n  // insertion positions because it mutates the list.\n  insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1);\n\n  if (insertBefore1 !== insertBefore2) {\n    // The insertion positions are different, so we need to clone the update and\n    // insert the clone into the alternate queue.\n    const update2 = cloneUpdate(update);\n    insertUpdateIntoQueue(queue2, update2, insertAfter2, insertBefore2);\n    return update2;\n  } else {\n    // The insertion positions are the same, so when we inserted into the first\n    // queue, it also inserted into the alternate. All we need to do is update\n    // the alternate queue's `first` and `last` pointers, in case they\n    // have changed.\n    if (insertAfter2 === null) {\n      queue2.first = update;\n    }\n    if (insertBefore2 === null) {\n      queue2.last = null;\n    }\n  }\n\n  return null;\n}\n\nfunction addUpdate(\n  fiber: Fiber,\n  partialState: PartialState<any, any> | null,\n  callback: mixed,\n  priorityLevel: PriorityLevel,\n): void {\n  const update = {\n    priorityLevel,\n    partialState,\n    callback,\n    isReplace: false,\n    isForced: false,\n    isTopLevelUnmount: false,\n    next: null,\n  };\n  insertUpdate(fiber, update);\n}\nexports.addUpdate = addUpdate;\n\nfunction addReplaceUpdate(\n  fiber: Fiber,\n  state: any | null,\n  callback: Callback | null,\n  priorityLevel: PriorityLevel,\n): void {\n  const update = {\n    priorityLevel,\n    partialState: state,\n    callback,\n    isReplace: true,\n    isForced: false,\n    isTopLevelUnmount: false,\n    next: null,\n  };\n  insertUpdate(fiber, update);\n}\nexports.addReplaceUpdate = addReplaceUpdate;\n\nfunction addForceUpdate(\n  fiber: Fiber,\n  callback: Callback | null,\n  priorityLevel: PriorityLevel,\n): void {\n  const update = {\n    priorityLevel,\n    partialState: null,\n    callback,\n    isReplace: false,\n    isForced: true,\n    isTopLevelUnmount: false,\n    next: null,\n  };\n  insertUpdate(fiber, update);\n}\nexports.addForceUpdate = addForceUpdate;\n\nfunction getPendingPriority(queue: UpdateQueue): PriorityLevel {\n  return queue.first !== null ? queue.first.priorityLevel : NoWork;\n}\nexports.getPendingPriority = getPendingPriority;\n\nfunction addTopLevelUpdate(\n  fiber: Fiber,\n  partialState: PartialState<any, any>,\n  callback: Callback | null,\n  priorityLevel: PriorityLevel,\n): void {\n  const isTopLevelUnmount = partialState.element === null;\n\n  const update = {\n    priorityLevel,\n    partialState,\n    callback,\n    isReplace: false,\n    isForced: false,\n    isTopLevelUnmount,\n    next: null,\n  };\n  const update2 = insertUpdate(fiber, update);\n\n  if (isTopLevelUnmount) {\n    // Drop all updates that are lower-priority, so that the tree is not\n    // remounted. We need to do this for both queues.\n    const queue1 = fiber.updateQueue;\n    const queue2 = fiber.alternate !== null\n      ? fiber.alternate.updateQueue\n      : null;\n\n    if (queue1 !== null && update.next !== null) {\n      update.next = null;\n      queue1.last = update;\n    }\n    if (queue2 !== null && update2 !== null && update2.next !== null) {\n      update2.next = null;\n      queue2.last = update;\n    }\n  }\n}\nexports.addTopLevelUpdate = addTopLevelUpdate;\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  const partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    const updateFn = partialState;\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction beginUpdateQueue(\n  workInProgress: Fiber,\n  queue: UpdateQueue,\n  instance: any,\n  prevState: any,\n  props: any,\n  priorityLevel: PriorityLevel,\n): any {\n  if (__DEV__) {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  queue.hasForceUpdate = false;\n\n  // Applies updates with matching priority to the previous state to create\n  // a new state object.\n  let state = prevState;\n  let dontMutatePrevState = true;\n  let callbackList = null;\n  let update = queue.first;\n  while (\n    update !== null && comparePriority(update.priorityLevel, priorityLevel) <= 0\n  ) {\n    // Remove each update from the queue right before it is processed. That way\n    // if setState is called from inside an updater function, the new update\n    // will be inserted in the correct position.\n    queue.first = update.next;\n    if (queue.first === null) {\n      queue.last = null;\n    }\n\n    let partialState;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      partialState = getStateFromUpdate(update, instance, state, props);\n      if (partialState) {\n        if (dontMutatePrevState) {\n          state = Object.assign({}, state, partialState);\n        } else {\n          state = Object.assign(state, partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    // Second condition ignores top-level unmount callbacks if they are not the\n    // last update in the queue, since a subsequent update will cause a remount.\n    if (\n      update.callback !== null &&\n      !(update.isTopLevelUnmount && update.next !== null)\n    ) {\n      callbackList = callbackList || [];\n      callbackList.push(update.callback);\n      workInProgress.effectTag |= CallbackEffect;\n    }\n    update = update.next;\n  }\n\n  queue.callbackList = callbackList;\n\n  if (queue.first === null && callbackList === null && !queue.hasForceUpdate) {\n    // The queue is empty and there are no callbacks. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (__DEV__) {\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\nexports.beginUpdateQueue = beginUpdateQueue;\n\nfunction commitCallbacks(\n  finishedWork: Fiber,\n  queue: UpdateQueue,\n  context: mixed,\n) {\n  const callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  for (let i = 0; i < callbackList.length; i++) {\n    const callback = callbackList[i];\n    invariant(\n      typeof callback === 'function',\n      'Invalid argument passed as callback. Expected a function. Instead ' +\n        'received: %s',\n      callback,\n    );\n    callback.call(context);\n  }\n}\nexports.commitCallbacks = commitCallbacks;\n"]}]