["e3734b88038661b22b88be0bd8996e4d34f9fd75","955836917d32743382566d185662d58e1089fa42",["ReactTypeOfWork","ReactPriorityLevel","ReactTypeOfSideEffect","ReactFiberUpdateQueue","fbjs/lib/invariant","getComponentName"],[47,546,624,710,812,884],{"version":3,"sources":["/var/www/geruapp/node_modules/react-native/Libraries/Renderer/src/renderers/shared/fiber/ReactFiber.js"],"names":["ReactTypeOfWork","require","IndeterminateComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","CoroutineComponent","YieldComponent","Fragment","NoWork","NoEffect","cloneUpdateQueue","invariant","__DEV__","getComponentName","debugCounter","createFiber","tag","key","fiber","type","stateNode","return","child","sibling","index","ref","pendingProps","memoizedProps","updateQueue","memoizedState","effectTag","nextEffect","firstEffect","lastEffect","pendingWorkPriority","progressedPriority","progressedChild","progressedFirstDeletion","progressedLastDeletion","alternate","_debugID","_debugSource","_debugOwner","_debugIsCurrentlyTiming","Object","preventExtensions","shouldConstruct","Component","prototype","isReactComponent","exports","cloneFiber","priorityLevel","alt","createHostRootFiber","createFiberFromElement","element","owner","_owner","createFiberFromElementType","props","_source","createFiberFromFragment","elements","createFiberFromText","content","debugOwner","info","undefined","keys","length","ownerName","createFiberFromCoroutine","coroutine","handler","createFiberFromYield","yieldNode","createFiberFromPortal","portal","children","containerInfo","implementation"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactFiber\n * @flow\n */\n\n'use strict';\n\nimport type {ReactElement, Source} from 'ReactElementType';\nimport type {ReactInstance, DebugID} from 'ReactInstanceType';\nimport type {ReactFragment} from 'ReactTypes';\nimport type {ReactCoroutine, ReactYield} from 'ReactCoroutine';\nimport type {ReactPortal} from 'ReactPortal';\nimport type {TypeOfWork} from 'ReactTypeOfWork';\nimport type {TypeOfSideEffect} from 'ReactTypeOfSideEffect';\nimport type {PriorityLevel} from 'ReactPriorityLevel';\nimport type {UpdateQueue} from 'ReactFiberUpdateQueue';\n\nvar ReactTypeOfWork = require('ReactTypeOfWork');\nvar {\n  IndeterminateComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  CoroutineComponent,\n  YieldComponent,\n  Fragment,\n} = ReactTypeOfWork;\n\nvar {\n  NoWork,\n} = require('ReactPriorityLevel');\n\nvar {\n  NoEffect,\n} = require('ReactTypeOfSideEffect');\n\nvar {\n  cloneUpdateQueue,\n} = require('ReactFiberUpdateQueue');\n\nvar invariant = require('fbjs/lib/invariant');\n\nif (__DEV__) {\n  var getComponentName = require('getComponentName');\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\nexport type Fiber = {\n  // __DEV__ only\n  _debugID?: DebugID,\n  _debugSource?: Source | null,\n  _debugOwner?: Fiber | ReactInstance | null, // Stack compatible\n  _debugIsCurrentlyTiming?: boolean,\n\n  // These first fields are conceptually members of an Instance. This used to\n  // be split into a separate type and intersected with the other Fiber fields,\n  // but until Flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // An Instance is shared between all versions of a component. We can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. We put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n\n  // Tag identifying the type of fiber.\n  tag: TypeOfWork,\n\n  // Unique identifier of this child.\n  key: null | string,\n\n  // The function/class/module associated with this fiber.\n  type: any,\n\n  // The local state associated with this fiber.\n  stateNode: any,\n\n  // Conceptual aliases\n  // parent : Instance -> return The parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // Remaining fields belong to Fiber\n\n  // The Fiber to return to after finishing processing this one.\n  // This is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // It is conceptually the same as the return address of a stack frame.\n  return: Fiber | null,\n\n  // Singly Linked List Tree Structure.\n  child: Fiber | null,\n  sibling: Fiber | null,\n  index: number,\n\n  // The ref last used to attach this node.\n  // I'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}),\n\n  // Input is the data coming into process this fiber. Arguments. Props.\n  pendingProps: any, // This type will be more specific once we overload the tag.\n  // TODO: I think that there is a way to merge pendingProps and memoizedProps.\n  memoizedProps: any, // The props used to create the output.\n\n  // A queue of state updates and callbacks.\n  updateQueue: UpdateQueue | null,\n\n  // The state used to create the output\n  memoizedState: any,\n\n  // Effect\n  effectTag: TypeOfSideEffect,\n\n  // Singly linked list fast path to the next fiber with side-effects.\n  nextEffect: Fiber | null,\n\n  // The first and last fiber with side-effect within this subtree. This allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  firstEffect: Fiber | null,\n  lastEffect: Fiber | null,\n\n  // This will be used to quickly determine if a subtree has no pending changes.\n  pendingWorkPriority: PriorityLevel,\n\n  // This value represents the priority level that was last used to process this\n  // component. This indicates whether it is better to continue from the\n  // progressed work or if it is better to continue from the current state.\n  progressedPriority: PriorityLevel,\n\n  // If work bails out on a Fiber that already had some work started at a lower\n  // priority, then we need to store the progressed work somewhere. This holds\n  // the started child set until we need to get back to working on it. It may\n  // or may not be the same as the \"current\" child.\n  progressedChild: Fiber | null,\n\n  // When we reconcile children onto progressedChild it is possible that we have\n  // to delete some child fibers. We need to keep track of this side-effects so\n  // that if we continue later on, we have to include those effects. Deletions\n  // are added in the reverse order from sibling pointers.\n  progressedFirstDeletion: Fiber | null,\n  progressedLastDeletion: Fiber | null,\n\n  // This is a pooled version of a Fiber. Every fiber that gets updated will\n  // eventually have a pair. There are cases when we can clean up pairs to save\n  // memory if we need to.\n  alternate: Fiber | null,\n\n  // Conceptual aliases\n  // workInProgress : Fiber ->  alternate The alternate used for reuse happens\n  // to be the same as work in progress.\n};\n\nif (__DEV__) {\n  var debugCounter = 1;\n}\n\n// This is a constructor of a POJO instead of a constructor function for a few\n// reasons:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We can easily go from a createFiber call to calling a constructor if that\n//    is faster. The opposite is not true.\n// 4) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag: TypeOfWork, key: null | string): Fiber {\n  var fiber: Fiber = {\n    // Instance\n\n    tag: tag,\n\n    key: key,\n\n    type: null,\n\n    stateNode: null,\n\n    // Fiber\n\n    return: null,\n\n    child: null,\n    sibling: null,\n    index: 0,\n\n    ref: null,\n\n    pendingProps: null,\n    memoizedProps: null,\n    updateQueue: null,\n    memoizedState: null,\n\n    effectTag: NoEffect,\n    nextEffect: null,\n    firstEffect: null,\n    lastEffect: null,\n\n    pendingWorkPriority: NoWork,\n    progressedPriority: NoWork,\n    progressedChild: null,\n    progressedFirstDeletion: null,\n    progressedLastDeletion: null,\n\n    alternate: null,\n  };\n\n  if (__DEV__) {\n    fiber._debugID = debugCounter++;\n    fiber._debugSource = null;\n    fiber._debugOwner = null;\n    fiber._debugIsCurrentlyTiming = false;\n    if (typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(fiber);\n    }\n  }\n\n  return fiber;\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\n// TODO: Rename to createWorkInProgressFiber or something like that.\nexports.cloneFiber = function(\n  fiber: Fiber,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  // We clone to get a work in progress. That means that this fiber is the\n  // current. To make it safe to reuse that fiber later on as work in progress\n  // we need to reset its work in progress flag now. We don't have an\n  // opportunity to do this earlier since we don't traverse the tree when\n  // the work in progress tree becomes the current tree.\n  // fiber.progressedPriority = NoWork;\n  // fiber.progressedChild = null;\n\n  // We use a double buffering pooling technique because we know that we'll only\n  // ever need at most two versions of a tree. We pool the \"other\" unused node\n  // that we're free to reuse. This is lazily created to avoid allocating extra\n  // objects for things that are never updated. It also allow us to reclaim the\n  // extra memory if needed.\n  let alt = fiber.alternate;\n  if (alt !== null) {\n    // If we clone, then we do so from the \"current\" state. The current state\n    // can't have any side-effects that are still valid so we reset just to be\n    // sure.\n    alt.effectTag = NoEffect;\n    alt.nextEffect = null;\n    alt.firstEffect = null;\n    alt.lastEffect = null;\n  } else {\n    // This should not have an alternate already\n    alt = createFiber(fiber.tag, fiber.key);\n    alt.type = fiber.type;\n\n    alt.progressedChild = fiber.progressedChild;\n    alt.progressedPriority = fiber.progressedPriority;\n\n    alt.alternate = fiber;\n    fiber.alternate = alt;\n  }\n\n  alt.stateNode = fiber.stateNode;\n  alt.child = fiber.child;\n  alt.sibling = fiber.sibling; // This should always be overridden. TODO: null\n  alt.index = fiber.index; // This should always be overridden.\n  alt.ref = fiber.ref;\n  // pendingProps is here for symmetry but is unnecessary in practice for now.\n  // TODO: Pass in the new pendingProps as an argument maybe?\n  alt.pendingProps = fiber.pendingProps;\n  cloneUpdateQueue(fiber, alt);\n  alt.pendingWorkPriority = priorityLevel;\n\n  alt.memoizedProps = fiber.memoizedProps;\n  alt.memoizedState = fiber.memoizedState;\n\n  if (__DEV__) {\n    alt._debugID = fiber._debugID;\n    alt._debugSource = fiber._debugSource;\n    alt._debugOwner = fiber._debugOwner;\n  }\n\n  return alt;\n};\n\nexports.createHostRootFiber = function(): Fiber {\n  const fiber = createFiber(HostRoot, null);\n  return fiber;\n};\n\nexports.createFiberFromElement = function(\n  element: ReactElement,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  let owner = null;\n  if (__DEV__) {\n    owner = element._owner;\n  }\n\n  const fiber = createFiberFromElementType(element.type, element.key, owner);\n  fiber.pendingProps = element.props;\n  fiber.pendingWorkPriority = priorityLevel;\n\n  if (__DEV__) {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n};\n\nexports.createFiberFromFragment = function(\n  elements: ReactFragment,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  // TODO: Consider supporting keyed fragments. Technically, we accidentally\n  // support that in the existing React.\n  const fiber = createFiber(Fragment, null);\n  fiber.pendingProps = elements;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nexports.createFiberFromText = function(\n  content: string,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  const fiber = createFiber(HostText, null);\n  fiber.pendingProps = content;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nfunction createFiberFromElementType(\n  type: mixed,\n  key: null | string,\n  debugOwner: null | Fiber | ReactInstance,\n): Fiber {\n  let fiber;\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type)\n      ? createFiber(ClassComponent, key)\n      : createFiber(IndeterminateComponent, key);\n    fiber.type = type;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key);\n    fiber.type = type;\n  } else if (\n    typeof type === 'object' && type !== null && typeof type.tag === 'number'\n  ) {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = ((type: any): Fiber);\n  } else {\n    let info = '';\n    if (__DEV__) {\n      if (\n        type === undefined ||\n        (typeof type === 'object' &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info += ' You likely forgot to export your component from the file ' +\n          \"it's defined in.\";\n      }\n      const ownerName = debugOwner ? getComponentName(debugOwner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(\n      false,\n      'Element type is invalid: expected a string (for built-in components) ' +\n        'or a class/function (for composite components) but got: %s.%s',\n      type == null ? type : typeof type,\n      info,\n    );\n  }\n  return fiber;\n}\n\nexports.createFiberFromElementType = createFiberFromElementType;\n\nexports.createFiberFromCoroutine = function(\n  coroutine: ReactCoroutine,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  const fiber = createFiber(CoroutineComponent, coroutine.key);\n  fiber.type = coroutine.handler;\n  fiber.pendingProps = coroutine;\n  fiber.pendingWorkPriority = priorityLevel;\n  return fiber;\n};\n\nexports.createFiberFromYield = function(\n  yieldNode: ReactYield,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  const fiber = createFiber(YieldComponent, null);\n  return fiber;\n};\n\nexports.createFiberFromPortal = function(\n  portal: ReactPortal,\n  priorityLevel: PriorityLevel,\n): Fiber {\n  const fiber = createFiber(HostPortal, portal.key);\n  fiber.pendingProps = portal.children || [];\n  fiber.pendingWorkPriority = priorityLevel;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    implementation: portal.implementation,\n  };\n  return fiber;\n};\n"]}]